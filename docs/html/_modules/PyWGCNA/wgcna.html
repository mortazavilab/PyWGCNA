<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyWGCNA.wgcna &mdash; PyWGCNA  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> PyWGCNA
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#tutorials">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">API Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyWGCNA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>PyWGCNA.wgcna</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for PyWGCNA.wgcna</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">import</span> <span class="nn">statistics</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">linkage</span><span class="p">,</span> <span class="n">cut_tree</span><span class="p">,</span> <span class="n">dendrogram</span><span class="p">,</span> <span class="n">fcluster</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">t</span>
<span class="kn">from</span> <span class="nn">statsmodels.formula.api</span> <span class="kn">import</span> <span class="n">ols</span>
<span class="kn">import</span> <span class="nn">resource</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span> <span class="k">as</span> <span class="n">mcolors</span>
<span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">KNNImputer</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">gridspec</span>
<span class="kn">import</span> <span class="nn">gseapy</span> <span class="k">as</span> <span class="nn">gp</span>
<span class="kn">from</span> <span class="nn">gseapy.plot</span> <span class="kn">import</span> <span class="n">dotplot</span>
<span class="kn">from</span> <span class="nn">pyvis.network</span> <span class="kn">import</span> <span class="n">Network</span>

<span class="kn">from</span> <span class="nn">PyWGCNA.geneExp</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># remove runtime warning (divided by zero)</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;axes.edgecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;axes.linewidth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;axes.facecolor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;white&quot;</span>

<span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s2">&quot;white&quot;</span><span class="p">)</span>

<span class="c1"># public values</span>
<span class="n">networkTypes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span> <span class="s2">&quot;signed&quot;</span><span class="p">,</span> <span class="s2">&quot;signed hybrid&quot;</span><span class="p">]</span>
<span class="n">adjacencyTypes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span> <span class="s2">&quot;signed&quot;</span><span class="p">,</span> <span class="s2">&quot;signed hybrid&quot;</span><span class="p">]</span>
<span class="n">TOMTypes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span> <span class="s2">&quot;signed&quot;</span><span class="p">]</span>
<span class="n">TOMDenoms</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">]</span>

<span class="c1"># bcolors</span>
<span class="n">HEADER</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[95m&#39;</span>
<span class="n">OKBLUE</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[94m&#39;</span>
<span class="n">OKCYAN</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[96m&#39;</span>
<span class="n">OKGREEN</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[92m&#39;</span>
<span class="n">WARNING</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[93m&#39;</span>
<span class="n">FAIL</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[91m&#39;</span>
<span class="n">ENDC</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[0m&#39;</span>
<span class="n">BOLD</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[1m&#39;</span>
<span class="n">UNDERLINE</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[4m&#39;</span>


<div class="viewcode-block" id="WGCNA"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA">[docs]</a><span class="k">class</span> <span class="nc">WGCNA</span><span class="p">(</span><span class="n">GeneExp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used to do weighted gene co-expression network analysis.</span>

<span class="sd">    :param name: name of the WGCNA we used to visualize data (default: &#39;WGCNA&#39;)</span>
<span class="sd">    :type name: str</span>
<span class="sd">    :param save: indicate if you want to save result of important steps in a figure directory (default: False)</span>
<span class="sd">    :type save: bool</span>
<span class="sd">    :param outputPath: path you want to save all you figures and object (default: &#39;&#39;, where you rau your script)</span>
<span class="sd">    :type outputPath: str</span>
<span class="sd">    :param geneExpr: expression matrix</span>
<span class="sd">    :type geneExpr: geneExp class</span>
<span class="sd">    :param datExpr: data expression data that contains preprocessed data</span>
<span class="sd">    :type datExpr: anndata</span>
<span class="sd">    :param TPMcutoff: cut off for removing genes that expressed under this number along samples</span>
<span class="sd">    :type TPMcutoff: int</span>
<span class="sd">    :param cut: number to remove outlier sample (default: &#39;inf&#39;) By default we don&#39;t remove any sample by hierarchical clustering</span>
<span class="sd">    :type cut: float</span>
<span class="sd">    :param powers: different powers to test to have scale free network (default: [1:10, 11:21:2])</span>
<span class="sd">    :type powers: list of int</span>
<span class="sd">    :param RsquaredCut: R squaered cut to choose power for having scale free network; between 0 to 1 (default: 0.9)</span>
<span class="sd">    :type RsquaredCut: float</span>
<span class="sd">    :param MeanCut: mean connectivity to choose power for having scale free network (default: 100)</span>
<span class="sd">    :type MeanCut: int</span>
<span class="sd">    :param power: power to have scale free network (default: 6)</span>
<span class="sd">    :type power: int</span>
<span class="sd">    :param sft: soft threshold table which has information for each powers</span>
<span class="sd">    :type sft: pandas dataframe</span>
<span class="sd">    :param networkType: Type of network we can create including &quot;unsigned&quot;, &quot;signed&quot; and &quot;signed hybrid&quot; (default: &quot;signed hybrid&quot;)</span>
<span class="sd">    :type networkType: str</span>
<span class="sd">    :param adjacency: adjacency matrix calculating base of the type of network</span>
<span class="sd">    :type adjacency: ndarray</span>
<span class="sd">    :param geneTree: average hierarchical clustering of dissTOM matrix</span>
<span class="sd">    :type geneTree: ndarray</span>
<span class="sd">    :param TOMType: Type of topological overlap matrix(TOM) including &quot;unsigned&quot;, &quot;signed&quot; (default: &quot;signed&quot;)</span>
<span class="sd">    :type TOMType: str</span>
<span class="sd">    :param TOM: topological overlap measure using average linkage hierarchical clustering which inputs a measure of interconnectedness</span>
<span class="sd">    :param TOM: ndarray</span>
<span class="sd">    :param minModuleSize: We like large modules, so we set the minimum module size relatively high (default: 50)</span>
<span class="sd">    :type minModuleSize: int</span>
<span class="sd">    :param dynamicMods: name of modules by clustering similar genes together</span>
<span class="sd">    :type dynamicMods: list</span>
<span class="sd">    :param naColor: color we used to identify genes we don&#39;t find any cluster for them (default: &quot;grey&quot;)</span>
<span class="sd">    :type naColor: str</span>
<span class="sd">    :param MEs: eigengenes</span>
<span class="sd">    :type MEs: ndarray</span>
<span class="sd">    :param MEDissThres:  diss similarity threshold (default: 0.2)</span>
<span class="sd">    :type MEDissThres: float</span>
<span class="sd">    :param datME:</span>
<span class="sd">    :type datME: pandas dataframe</span>
<span class="sd">    :param signedKME:(signed) eigengene-based connectivity (module membership)</span>
<span class="sd">    :type signedKME: pandas dataframe</span>
<span class="sd">    :param moduleTraitCor: correlation between each module and metadata</span>
<span class="sd">    :type moduleTraitCor: pandas dataframe</span>
<span class="sd">    :param moduleTraitPvalue: p-value of correlation between each module and metadata</span>
<span class="sd">    :type moduleTraitPvalue: pandas dataframe</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;WGCNA&#39;</span><span class="p">,</span>
                 <span class="n">TPMcutoff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">powers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">RsquaredCut</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">MeanCut</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">networkType</span><span class="o">=</span><span class="s2">&quot;signed hybrid&quot;</span><span class="p">,</span> <span class="n">TOMType</span><span class="o">=</span><span class="s2">&quot;signed&quot;</span><span class="p">,</span>
                 <span class="n">minModuleSize</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">naColor</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>
                 <span class="n">MEDissThres</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                 <span class="n">species</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">anndata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geneExp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">geneExpPath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
                 <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outputPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">anndata</span><span class="o">=</span><span class="n">anndata</span><span class="p">,</span> <span class="n">geneExp</span><span class="o">=</span><span class="n">geneExp</span><span class="p">,</span>
                         <span class="n">geneExpPath</span><span class="o">=</span><span class="n">geneExpPath</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">powers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">powers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">save</span> <span class="o">=</span> <span class="n">save</span>
        <span class="k">if</span> <span class="n">outputPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">TPMcutoff</span> <span class="o">=</span> <span class="n">TPMcutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geneExpr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">networkType</span> <span class="o">=</span> <span class="n">networkType</span>

        <span class="c1"># Choose a set of soft-thresholding powers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RsquaredCut</span> <span class="o">=</span> <span class="n">RsquaredCut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MeanCut</span> <span class="o">=</span> <span class="n">MeanCut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">powers</span> <span class="o">=</span> <span class="n">powers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sft</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geneTree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOMType</span> <span class="o">=</span> <span class="n">TOMType</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOM</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minModuleSize</span> <span class="o">=</span> <span class="n">minModuleSize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamicMods</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">naColor</span> <span class="o">=</span> <span class="n">naColor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEDissThres</span> <span class="o">=</span> <span class="n">MEDissThres</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">datME</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitPvalue</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2">Saving data to be True, checking requirements ...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/&#39;</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Figure directory does not exist!</span><span class="se">\n</span><span class="s2">Creating figure directory!</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="WGCNA.preprocess"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocessing PyWGCNA object including removing obvious outlier on genes and samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">BOLD</span><span class="si">}{</span><span class="n">OKBLUE</span><span class="si">}</span><span class="s2">Pre-processing...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare and clean data</span>
        <span class="c1"># Remove cols with less than 1 TPM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="p">[:,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">X</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">TPMcutoff</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>

        <span class="c1"># Check that all genes and samples have sufficiently low numbers of missing values.</span>
        <span class="n">goodGenes</span><span class="p">,</span> <span class="n">goodSamples</span><span class="p">,</span> <span class="n">allOK</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">goodSamplesGenes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># if not okay</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allOK</span><span class="p">:</span>
            <span class="c1"># Optionally, print the gene and sample names that were removed:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">goodGenes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">goodGenes</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">goodGenes</span><span class="p">)</span><span class="si">}</span><span class="s2"> gene(s) detected as an outlier!</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2">Removing genes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="ow">not</span> <span class="n">goodGenes</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="si">}{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span><span class="si">}</span><span class="s2"> sample(s) detected as an outlier!</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2">Removing samples: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="ow">not</span> <span class="n">goodSamples</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="si">}{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Remove the offending genes and samples from the data:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">goodSamples</span><span class="p">,</span> <span class="n">goodGenes</span><span class="p">]</span>

        <span class="c1"># Clustering</span>
        <span class="n">sampleTree</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">dendrogram</span><span class="p">(</span><span class="n">sampleTree</span><span class="p">,</span> <span class="n">color_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">leaf_rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span>
                   <span class="n">leaf_font_size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Sample clustering to detect outliers&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Samples&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Distances&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/sampleClusteringCleaning.png&#39;</span><span class="p">)</span>

        <span class="c1"># Determine cluster under the line</span>
        <span class="n">clust</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">cutree</span><span class="p">(</span><span class="n">sampleTree</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cut</span><span class="p">)</span>
        <span class="c1"># clust 0 contains the samples we want to keep.</span>
        <span class="n">clust</span> <span class="o">=</span> <span class="n">clust</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clust</span><span class="p">)</span> <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done pre-processing..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.findModules"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.findModules">[docs]</a>    <span class="k">def</span> <span class="nf">findModules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clustering genes through original WGCNA pipeline: 1.pick soft threshold 2.calculating adjacency matrix 3.calculating TOM similarity matrix 4.cluster genes base of dissTOM 5.merge similar cluster dynamically</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">BOLD</span><span class="si">}{</span><span class="n">OKBLUE</span><span class="si">}</span><span class="s2">Run WGCNA...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Call the network topology analysis function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sft</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">pickSoftThreshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">(),</span> <span class="n">RsquaredCut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">RsquaredCut</span><span class="p">,</span>
                                                       <span class="n">MeanCut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MeanCut</span><span class="p">,</span> <span class="n">powerVector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">powers</span><span class="p">,</span>
                                                       <span class="n">networkType</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">networkType</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="p">[</span><span class="s1">&#39;Power&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="p">[</span><span class="s1">&#39;SFT.R.sq&#39;</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">powers</span><span class="p">)):</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Power&#39;</span><span class="p">],</span>
                       <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;slope&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;SFT.R.sq&#39;</span><span class="p">],</span>
                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Power&#39;</span><span class="p">]),</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Soft Threshold (power)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Scale Free Topology Model Fit,signed R^2&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;Scale independence&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="p">[</span><span class="s1">&#39;Power&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="p">[</span><span class="s1">&#39;mean(k)&#39;</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">powers</span><span class="p">)):</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Power&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;mean(k)&#39;</span><span class="p">],</span>
                       <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sft</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Power&#39;</span><span class="p">]),</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Soft Threshold (power)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Mean Connectivity&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;Mean connectivity&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/summarypower.png&#39;</span><span class="p">)</span>

        <span class="c1"># Set Power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">adjacency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">(),</span> <span class="n">power</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">,</span> <span class="n">adjacencyType</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">networkType</span><span class="p">)</span>

        <span class="c1"># Turn adjacency into topological overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOM</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">TOMsimilarity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjacency</span><span class="p">,</span> <span class="n">TOMType</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TOMType</span><span class="p">)</span>
        <span class="n">dissTOM</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">TOM</span>
        <span class="n">dissTOM</span> <span class="o">=</span> <span class="n">dissTOM</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">dissTOM</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Call the hierarchical clustering function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geneTree</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>

        <span class="c1"># Module identification using dynamic tree cut:</span>
        <span class="n">dynamicMods</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">cutreeHybrid</span><span class="p">(</span><span class="n">dendro</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geneTree</span><span class="p">,</span> <span class="n">distM</span><span class="o">=</span><span class="n">dissTOM</span><span class="p">,</span> <span class="n">deepSplit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pamRespectsDendro</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">minClusterSize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minModuleSize</span><span class="p">)</span>

        <span class="c1"># Convert numeric labels into colors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;dynamicColors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">labels2colors</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">dynamicMods</span><span class="p">)</span>

        <span class="c1"># Calculate eigengenes</span>
        <span class="n">MEList</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">moduleEigengenes</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">(),</span> <span class="n">colors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;dynamicColors&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span> <span class="o">=</span> <span class="n">MEList</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;MEgrey&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;MEgrey&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate dissimilarity of module eigengenes</span>
        <span class="n">MEDiss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># Cluster module eigengenes</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">MEDiss</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">METree</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">MEDiss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)),</span> <span class="mi">10</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">dendrogram</span><span class="p">(</span><span class="n">METree</span><span class="p">,</span> <span class="n">color_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MEDissThres</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">MEDiss</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">leaf_rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span>
                   <span class="n">leaf_font_size</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MEDissThres</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Clustering of module eigengenes&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/eigenesgenes.png&#39;</span><span class="p">)</span>

        <span class="c1"># Call an automatic merging function</span>
        <span class="n">merge</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">mergeCloseModules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;dynamicColors&#39;</span><span class="p">],</span>
                                        <span class="n">cutHeight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MEDissThres</span><span class="p">)</span>
        <span class="c1"># The merged module colors; Rename to moduleColors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">[</span><span class="s1">&#39;colors&#39;</span><span class="p">]</span>
        <span class="c1"># Construct numerical labels corresponding to the colors</span>
        <span class="n">colorOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleLabels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">colorOrder</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">colorOrder</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">]]</span>
        <span class="c1"># Eigengenes of the new merged modules:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span> <span class="o">=</span> <span class="n">merge</span><span class="p">[</span><span class="s1">&#39;newMEs&#39;</span><span class="p">]</span>

        <span class="c1"># Recalculate MEs with color labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datME</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">moduleEigengenes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;MEgrey&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;MEgrey&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">orderMEs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done running WGCNA..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.runWGCNA"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.runWGCNA">[docs]</a>    <span class="k">def</span> <span class="nf">runWGCNA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocess and find modules</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">WGCNA</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">WGCNA</span><span class="o">.</span><span class="n">findModules</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="WGCNA.analyseWGCNA"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.analyseWGCNA">[docs]</a>    <span class="k">def</span> <span class="nf">analyseWGCNA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geneList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analysing results: 1.calculating module trait relationship 2.plotting module heatmap eigengene 3.finding GO term for each module</span>

<span class="sd">        :param order: indicate in which order metadata will show up in plots (should same as metadata name in anndata)</span>
<span class="sd">        :type order: list</span>
<span class="sd">        :param geneList: genes information you want to add (keep in mind you can not have multiple row for same gene)</span>
<span class="sd">        :type geneList: pandas dataframe</span>
<span class="sd">        :param show: indicate if you want to see plots in when you run your code</span>
<span class="sd">        :type show: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">BOLD</span><span class="si">}{</span><span class="n">OKBLUE</span><span class="si">}</span><span class="s2">Analysing WGCNA...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">datTraits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDatTraits</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">Calculating module trait relationship ...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Define numbers of genes and samples</span>
        <span class="n">nGenes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">datTraits</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">datTraits</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                                           <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitPvalue</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">corPvalue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span><span class="p">,</span> <span class="n">nSamples</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitPvalue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitPvalue</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="c1"># names</span>
        <span class="n">xlabels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">xlabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">datTraits</span><span class="o">.</span><span class="n">columns</span>

        <span class="c1"># Loop over data dimensions and create text annotations.</span>
        <span class="n">tmp_cor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tmp_pvalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitPvalue</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">(</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cor</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">cor</span><span class="p">,</span> <span class="n">pvalue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tmp_cor</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                                     <span class="n">tmp_pvalue</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())]))</span> \
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">font_scale</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moduleTraitCor</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span>
                          <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">annot_kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="s2">&quot;bold&quot;</span><span class="p">},</span>
                          <span class="n">xticklabels</span><span class="o">=</span><span class="n">xlabels</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">ylabels</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get_xmajorticklabels</span><span class="p">(),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get_ymajorticklabels</span><span class="p">(),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Module-trait Relationships heatmap for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                     <span class="n">fontsize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/Module-traitRelationships.png&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">Adding (signed) eigengene-based connectivity (module membership) ...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CalculateSignedKME</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geneList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">Updating gene information based on given gene list ...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updateGeneInfo</span><span class="p">(</span><span class="n">geneInfo</span><span class="o">=</span><span class="n">geneList</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">plotting module heatmap eigengene...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Select module probes</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;sample_id&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="n">metadata</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">order</span><span class="p">):</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">order</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Given order is not valid!&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plotModuleEigenGene</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">plotting module barplot eigengene...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Select module probes</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;sample_id&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">item</span> <span class="ow">in</span> <span class="n">order</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">):</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">order</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Given order is not valid!&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">barplotModuleEigenGene</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">colorBar</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">doing Go term analysis for each module...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;gene_name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="se">\t</span><span class="s2">gene name didn&#39;t found in gene information!</span><span class="se">\n\t</span><span class="s2"> Go term analysis can not be done</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">findGoTerm</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WGCNA.replaceMissing"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.replaceMissing">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">replaceMissing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">replaceWith</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replacing missing (NA) value with appropriate value (for integer number replace with 0 and for string replace with &quot;&quot;)</span>

<span class="sd">        :param x: value want to replace (single item)</span>
<span class="sd">        :type x: object</span>
<span class="sd">        :param replaceWith: define character you want to replace na value by looking at type of data</span>
<span class="sd">        :type replaceWith: object</span>

<span class="sd">        :return: object without any missing (NA) value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">replaceWith</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">():</span>
                <span class="n">replaceWith</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
                <span class="n">replaceWith</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Need &#39;replaceWith&#39;.&quot;</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">replaceWith</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="WGCNA.checkAndScaleWeights"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.checkAndScaleWeights">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">checkAndScaleWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check and scale weights of gene expression</span>
<span class="sd">        :param weights: weights of gene expression</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param expr: gene expression matrix</span>
<span class="sd">        :type expr: pandas dataframe</span>
<span class="sd">        :param scaleByMax: if you want to scale your weights by diving to max</span>
<span class="sd">        :type scaleByMax: boll</span>

<span class="sd">        :return: processed weights of gene expression</span>
<span class="sd">        :rtype: pandas dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">weights</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;When &#39;weights&#39; are given, they must have the same dimensions as &#39;expr&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Found negative weights. All weights must be non-negative.&quot;</span><span class="p">)</span>

        <span class="n">nf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Found non-finite weights. The corresponding data points will be removed.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">scaleByMax</span><span class="p">:</span>
            <span class="n">maxw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">maxw</span><span class="p">[</span><span class="n">maxw</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">maxw</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">weights</span></div>

    <span class="c1"># Check that all genes and samples have sufficiently low numbers of missing values.</span>
<div class="viewcode-block" id="WGCNA.goodSamplesGenes"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.goodSamplesGenes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">goodSamplesGenes</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minFraction</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">minNSamples</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">minNGenes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">minRelativeWeight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks data for missing entries, entries with weights below a threshold, and zero-variance genes. If necessary, the filtering is iterated.</span>

<span class="sd">        :param datExpr:expression data. A data frame in which columns are genes and rows ar samples.</span>
<span class="sd">        :type datExpr: pandas dataframe</span>
<span class="sd">        :param weights: optional observation weights in the same format (and dimensions) as datExpr.</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param minFraction: minimum fraction of non-missing samples for a gene to be considered good. (default = 1/2)</span>
<span class="sd">        :type minFraction: float</span>
<span class="sd">        :param minNSamples: minimum number of non-missing samples for a gene to be considered good. (default = 4)</span>
<span class="sd">        :type minNSamples: int</span>
<span class="sd">        :param minNGenes: minimum number of good genes for the data set to be considered fit for analysis. If the actual number of good genes falls below this threshold, an error will be issued. (default = 4)</span>
<span class="sd">        :type minNGenes: int</span>
<span class="sd">        :param tol: An optional &#39;small&#39; number to compare the variance against</span>
<span class="sd">        :type tol: float</span>
<span class="sd">        :param minRelativeWeight: observations whose relative weight is below this threshold will be considered missing. Here relative weight is weight divided by the maximum weight in the column (gene). (default = 0.1)</span>
<span class="sd">        :type minRelativeWeight: float</span>

<span class="sd">        :return: A triple containing (goodGenes, goodSamples, allOK) goodSamples: A logical vector with one entry per sample that is TRUE if the sample is considered good and FALSE otherwise. goodGenes: A logical vector with one entry per gene that is TRUE if the gene is considered good and FALSE otherwise. allOK: if everything is okay</span>
<span class="sd">        :rtype: list, list, bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">goodGenes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">goodSamples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nBadGenes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nBadSamples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Detecting genes and samples with too many missing values...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">goodGenes</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">goodGenesFun</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">goodSamples</span><span class="p">,</span> <span class="n">goodGenes</span><span class="p">,</span> <span class="n">minFraction</span><span class="o">=</span><span class="n">minFraction</span><span class="p">,</span>
                                           <span class="n">minNSamples</span><span class="o">=</span><span class="n">minNSamples</span><span class="p">,</span> <span class="n">minNGenes</span><span class="o">=</span><span class="n">minNGenes</span><span class="p">,</span>
                                           <span class="n">minRelativeWeight</span><span class="o">=</span><span class="n">minRelativeWeight</span><span class="p">,</span>
                                           <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">goodSamples</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">goodSamplesFun</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">goodSamples</span><span class="p">,</span> <span class="n">goodGenes</span><span class="p">,</span> <span class="n">minFraction</span><span class="o">=</span><span class="n">minFraction</span><span class="p">,</span>
                                               <span class="n">minNSamples</span><span class="o">=</span><span class="n">minNSamples</span><span class="p">,</span> <span class="n">minNGenes</span><span class="o">=</span><span class="n">minNGenes</span><span class="p">,</span>
                                               <span class="n">minRelativeWeight</span><span class="o">=</span><span class="n">minRelativeWeight</span><span class="p">)</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">goodGenes</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nBadGenes</span><span class="p">),</span>
                                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">nBadSamples</span><span class="p">))</span>
            <span class="n">nBadGenes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">goodGenes</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">nBadSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="nb">iter</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">allOK</span> <span class="o">=</span> <span class="p">(</span><span class="n">nBadGenes</span> <span class="o">+</span> <span class="n">nBadSamples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">goodGenes</span><span class="p">,</span> <span class="n">goodSamples</span><span class="p">,</span> <span class="n">allOK</span></div>

    <span class="c1"># Filter genes with too many missing entries</span>
<div class="viewcode-block" id="WGCNA.goodGenesFun"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.goodGenesFun">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">goodGenesFun</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useSamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useGenes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minFraction</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                     <span class="n">minNSamples</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">minNGenes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minRelativeWeight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check data for missing entries and returns a list of genes that have non-zero variance</span>

<span class="sd">        :param datExpr:expression data. A data frame in which columns are genes and rows ar samples.</span>
<span class="sd">        :type datExpr: pandas dataframe</span>
<span class="sd">        :param weights: optional observation weights in the same format (and dimensions) as datExpr.</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param useSamples: optional specifications of which samples to use for the check (Defaults to using all samples)</span>
<span class="sd">        :type useSamples: list of bool</span>
<span class="sd">        :param useGenes: optional specifications of genes for which to perform the check (Defaults to using all genes)</span>
<span class="sd">        :type useGenes: list of bool</span>
<span class="sd">        :param minFraction: minimum fraction of non-missing samples for a gene to be considered good. (default = 1/2)</span>
<span class="sd">        :type minFraction: float</span>
<span class="sd">        :param minNSamples: minimum number of non-missing samples for a gene to be considered good. (default = 4)</span>
<span class="sd">        :type minNSamples: int</span>
<span class="sd">        :param minNGenes: minimum number of good genes for the data set to be considered fit for analysis. If the actual number of good genes falls below this threshold, an error will be issued. (default = 4)</span>
<span class="sd">        :type minNGenes: int</span>
<span class="sd">        :param tol: An optional &#39;small&#39; number to compare the variance against</span>
<span class="sd">        :type tol: float</span>
<span class="sd">        :param minRelativeWeight: observations whose relative weight is below this threshold will be considered missing. Here relative weight is weight divided by the maximum weight in the column (gene). (default = 0.1)</span>
<span class="sd">        :type minRelativeWeight: float</span>

<span class="sd">        :return: A logical list with one entry per gene that is TRUE if the gene is considered good and FALSE otherwise. Note that all genes excluded by useGenes are automatically assigned FALSE.</span>
<span class="sd">        :rtype: list of bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;datExpr must contain numeric data.&quot;</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkAndScaleWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">datExpr</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-10</span> <span class="o">*</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">useGenes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useGenes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">useSamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">useGenes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Length of nGenes is not compatible with number of columns in datExpr.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">useSamples</span><span class="p">)</span> <span class="o">!=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Length of nSamples is not compatible with number of rows in datExpr.&quot;</span><span class="p">)</span>

        <span class="n">nSamples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">useSamples</span><span class="p">)</span>
        <span class="n">nGenes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">useGenes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nPresent</span> <span class="o">=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nPresent</span> <span class="o">=</span> <span class="p">(</span><span class="n">datExpr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span> <span class="ow">and</span>
                        <span class="n">weights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minRelativeWeight</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">gg</span> <span class="o">=</span> <span class="n">useGenes</span>
        <span class="n">gg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">nPresent</span> <span class="o">&lt;</span> <span class="n">minNSamples</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">datExpr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gg</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># var = var.sort_index(inplace=True)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need to be fix</span>
            <span class="c1"># TODO:colWeightedVars</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="n">var</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nNAsGenes</span> <span class="o">=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gg</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gg</span><span class="p">[</span><span class="n">gg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">nNAsGenes</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">minFraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">nSamples</span><span class="p">,</span> <span class="n">var</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
                                <span class="n">nSamples</span> <span class="o">-</span> <span class="n">nNAsGenes</span> <span class="o">&gt;=</span> <span class="n">minNSamples</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minNGenes</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Too few genes with valid expression levels in the required number of samples.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nGenes</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">  ..Excluding&quot;</span><span class="p">,</span> <span class="n">nGenes</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gg</span><span class="p">),</span>
                  <span class="s2">&quot;genes from the calculation due to too many missing samples or zero variance.</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gg</span></div>

    <span class="c1"># Filter samples with too many missing entries</span>
<div class="viewcode-block" id="WGCNA.goodSamplesFun"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.goodSamplesFun">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">goodSamplesFun</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useSamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useGenes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minFraction</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="n">minNSamples</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">minNGenes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">minRelativeWeight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check data for missing entries and returns a list of samples that have non-zero variance</span>

<span class="sd">        :param datExpr:expression data. A data frame in which columns are genes and rows ar samples.</span>
<span class="sd">        :type datExpr: pandas dataframe</span>
<span class="sd">        :param weights: optional observation weights in the same format (and dimensions) as datExpr.</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param useSamples: optional specifications of which samples to use for the check (Defaults to using all samples)</span>
<span class="sd">        :type useSamples: list of bool</span>
<span class="sd">        :param useGenes: optional specifications of genes for which to perform the check (Defaults to using all genes)</span>
<span class="sd">        :type useGenes: list of bool</span>
<span class="sd">        :param minFraction: minimum fraction of non-missing samples for a gene to be considered good. (default = 1/2)</span>
<span class="sd">        :type minFraction: float</span>
<span class="sd">        :param minNSamples: minimum number of non-missing samples for a gene to be considered good. (default = 4)</span>
<span class="sd">        :type minNSamples: int</span>
<span class="sd">        :param minNGenes: minimum number of good genes for the data set to be considered fit for analysis. If the actual number of good genes falls below this threshold, an error will be issued. (default = 4)</span>
<span class="sd">        :type minNGenes: int</span>
<span class="sd">        :param tol: An optional &#39;small&#39; number to compare the variance against</span>
<span class="sd">        :type tol: float</span>
<span class="sd">        :param minRelativeWeight: observations whose relative weight is below this threshold will be considered missing. Here relative weight is weight divided by the maximum weight in the column (gene). (default = 0.1)</span>
<span class="sd">        :type minRelativeWeight: float</span>

<span class="sd">        :return: A logical list with one entry per sample that is TRUE if the sample is considered good and FALSE otherwise. Note that all samples excluded by useSamples are automatically assigned FALSE.</span>
<span class="sd">        :rtype: list of bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">useGenes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useGenes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">useSamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">useGenes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Length of nGenes is not compatible with number of columns in datExpr.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">useSamples</span><span class="p">)</span> <span class="o">!=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Length of nSamples is not compatible with number of rows in datExpr.&quot;</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkAndScaleWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">datExpr</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">useSamples</span><span class="p">)</span>
        <span class="n">nGenes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">useGenes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nNAsSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">datExpr</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">])</span><span class="o">.</span><span class="n">isnull</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nNAsSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">datExpr</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">],</span>
                                               <span class="n">WGCNA</span><span class="o">.</span><span class="n">replaceMissing</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="n">useSamples</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minRelativeWeight</span><span class="p">,</span>
                                                                    <span class="kc">True</span><span class="p">))</span>
                                 <span class="o">.</span><span class="n">isnull</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">goodSamples</span> <span class="o">=</span> <span class="n">useSamples</span>
        <span class="n">goodSamples</span><span class="p">[</span><span class="n">useSamples</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">((</span><span class="n">nNAsSamples</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">minFraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">nGenes</span><span class="p">),</span>
                                                 <span class="p">(</span><span class="n">nGenes</span> <span class="o">-</span> <span class="n">nNAsSamples</span> <span class="o">&gt;=</span> <span class="n">minNGenes</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minNSamples</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Too few samples with valid expression levels for the required number of genes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nSamples</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ..Excluding&quot;</span><span class="p">,</span> <span class="n">nSamples</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">goodSamples</span><span class="p">),</span>
                  <span class="s2">&quot;samples from the calculation due to too many missing genes.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">goodSamples</span></div>

<div class="viewcode-block" id="WGCNA.hclust"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.hclust">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">hclust</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;complete&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hierarchical cluster analysis on a set of dissimilarities and methods for analyzing it.</span>

<span class="sd">        :param d: a dissimilarity structure as produced by &#39;pdist&#39;.</span>
<span class="sd">        :type d: ndarray</span>
<span class="sd">        :param method: The linkage algorithm to use. (default = complete)</span>
<span class="sd">        :type method: str</span>

<span class="sd">        :return: The hierarchical clustering encoded as a linkage matrix.</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;weighted&quot;</span><span class="p">,</span> <span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">METHODS</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Invalid clustering method.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Ambiguous clustering method.&quot;</span><span class="p">)</span>

        <span class="n">dendrogram</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dendrogram</span></div>

    <span class="c1"># Determine cluster under the line</span>
<div class="viewcode-block" id="WGCNA.cutree"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.cutree">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cutree</span><span class="p">(</span><span class="n">sampleTree</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="mf">50000.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a linkage matrix Z, return the cut tree. remove samples/genes/modules base on hierarchical clustering</span>

<span class="sd">        :param sampleTree: The linkage matrix.</span>
<span class="sd">        :type sampleTree: scipy.cluster.linkage array</span>
<span class="sd">        :param cutHeight: A optional height at which to cut the tree (default = 50000)</span>
<span class="sd">        :type cutHeight: array_like</span>

<span class="sd">        :return: An array indicating group membership at each agglomeration step. I.e., for a full cut tree, in the first column each data point is in its own cluster. At the next step, two nodes are merged. Finally, all singleton and non-singleton clusters are in one group. If n_clusters or height are given, the columns correspond to the columns of n_clusters or height.</span>
<span class="sd">        :rtype: array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cutTree</span> <span class="o">=</span> <span class="n">cut_tree</span><span class="p">(</span><span class="n">sampleTree</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">cutHeight</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cutTree</span></div>

    <span class="c1"># Call the network topology analysis function</span>
<div class="viewcode-block" id="WGCNA.pickSoftThreshold"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.pickSoftThreshold">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">pickSoftThreshold</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dataIsExpr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">RsquaredCut</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">MeanCut</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">powerVector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">nBreaks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                          <span class="n">blockSize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corOptions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">networkType</span><span class="o">=</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span> <span class="n">moreNetworkConcepts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">gcInterval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analysis of scale free topology for multiple soft thresholding powers.</span>

<span class="sd">        :param data: expression data in a matrix or data frame. Rows correspond to samples and columns to genes.</span>
<span class="sd">        :param data: pandas dataframe</span>
<span class="sd">        :param dataIsExpr: should the data be interpreted as expression (or other numeric) data, or as a similarity matrix of network nodes?</span>
<span class="sd">        :type dataIsExpr: bool</span>
<span class="sd">        :param weights: optional observation weights for data to be used in correlation calculation. A matrix of the same dimensions as datExpr, containing non-negative weights. Only used with Pearson correlation.</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param RsquaredCut: desired minimum scale free topology fitting index (R^2). (default = 0.9)</span>
<span class="sd">        :type RsquaredCut: float</span>
<span class="sd">        :param MeanCut: desired maximum mean connectivity scale free topology fitting index. (default = 100)</span>
<span class="sd">        :type MeanCut: int</span>
<span class="sd">        :param powerVector: A list of soft thresholding powers for which the scale free topology fit indices are to be calculated.</span>
<span class="sd">        :type powerVector: list of int</span>
<span class="sd">        :param nBreaks: number of bins in connectivity histograms (default = 10)</span>
<span class="sd">        :type nBreaks: int</span>
<span class="sd">        :param blockSize: block size into which the calculation of connectivity should be broken up. If not given, a suitable value will be calculated using function blockSize and printed if verbose&gt;0. If R runs into memory problems, decrease this value.</span>
<span class="sd">        :type blockSize: int</span>
<span class="sd">        :param corOptions: a list giving further options to the correlation function specified in corFnc.</span>
<span class="sd">        :type corOptions: list</span>
<span class="sd">        :param networkType: network type. Allowed values are (unique abbreviations of) &quot;unsigned&quot;, &quot;signed&quot;, &quot;signed hybrid&quot;. (default = unsigned)</span>
<span class="sd">        :type networkType: str</span>
<span class="sd">        :param moreNetworkConcepts: should additional network concepts be calculated? If TRUE, the function will calculate how the network density, the network heterogeneity, and the network centralization depend on the power. For the definition of these additional network concepts, see Horvath and Dong (2008). PloS Comp Biol.</span>
<span class="sd">        :type moreNetworkConcepts: bool</span>
<span class="sd">        :param gcInterval: a number specifying in interval (in terms of individual genes) in which garbage collection will be performed. The actual interval will never be less than blockSize.</span>
<span class="sd">        :type gcInterval: int</span>

<span class="sd">        :return: tuple including powerEstimate: estimate of an appropriate soft-thresholding power which is the lowest power for which the scale free topology fit \(R^2\) exceeds RsquaredCut and conectivity is less than MeanCut. If \(R^2\) is below RsquaredCut for all powers maximum will re returned and datout which is a data frame containing the fit indices for scale free topology. The columns contain the soft-thresholding power, adjusted \(R^2\) for the linear fit, the linear coefficient, adjusted \(R^2\) for a more complicated fit models, mean connectivity, median connectivity and maximum connectivity. If input moreNetworkConcepts is TRUE, 3 additional columns containing network density, centralization, and heterogeneity.</span>
<span class="sd">        :type: int and pandas dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">powerVector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">powerVector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">powerVector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">powerVector</span><span class="p">)</span>
        <span class="n">intType</span> <span class="o">=</span> <span class="n">networkTypes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">networkType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Unrecognized &#39;networkType&#39;. Recognized values are&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">networkTypes</span><span class="p">)))</span>

        <span class="n">nGenes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nGenes</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;The input data data contain fewer than 3 rows (nodes).</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;This would result in a trivial correlation network.&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">pickSoftThreshold: calculating connectivity for given powers...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataIsExpr</span><span class="p">:</span>
            <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSimilarity</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">blockSize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">blockSize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">calBlockSize</span><span class="p">(</span><span class="n">nGenes</span><span class="p">,</span> <span class="n">rectangularBlocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxMemoryAllocation</span><span class="o">=</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">30</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;will use block size &quot;</span><span class="p">,</span> <span class="n">blockSize</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gcInterval</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">gcInterval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gcInterval</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">blockSize</span>

        <span class="n">colname1</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Power&quot;</span><span class="p">,</span> <span class="s2">&quot;SFT.R.sq&quot;</span><span class="p">,</span> <span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated R.sq&quot;</span><span class="p">,</span> <span class="s2">&quot;mean(k)&quot;</span><span class="p">,</span> <span class="s2">&quot;median(k)&quot;</span><span class="p">,</span> <span class="s2">&quot;max(k)&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">moreNetworkConcepts</span><span class="p">:</span>
            <span class="n">colname1</span> <span class="o">=</span> <span class="n">colname1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;Density&quot;</span><span class="p">,</span> <span class="s2">&quot;Centralization&quot;</span><span class="p">,</span> <span class="s2">&quot;Heterogeneity&quot;</span><span class="p">])</span>

        <span class="n">datout</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">powerVector</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">colname1</span><span class="p">)),</span> <span class="mi">666</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">colname1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">datout</span><span class="p">[</span><span class="s1">&#39;Power&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">powerVector</span>

        <span class="n">datk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nGenes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">powerVector</span><span class="p">)))</span>
        <span class="n">nPowers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">powerVector</span><span class="p">)</span>
        <span class="n">startG</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lastGC</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">corOptions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corOptions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dataIsExpr</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Weights can only be used when &#39;data&#39; represents expression data (&#39;dataIsExpr&#39; must be TRUE).&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;When &#39;weights&#39; are given, dimensions of &#39;data&#39; and &#39;weights&#39; must be the same.&quot;</span><span class="p">)</span>
            <span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;weights.x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>

        <span class="k">while</span> <span class="n">startG</span> <span class="o">&lt;</span> <span class="n">nGenes</span><span class="p">:</span>
            <span class="n">endG</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">startG</span> <span class="o">+</span> <span class="n">blockSize</span><span class="p">,</span> <span class="n">nGenes</span><span class="p">)</span>

            <span class="n">useGenes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">startG</span><span class="p">,</span> <span class="n">endG</span><span class="p">))</span>
            <span class="n">nGenes1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">useGenes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dataIsExpr</span><span class="p">:</span>
                <span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">useGenes</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;weights.y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">weights</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">useGenes</span><span class="p">]]</span>
                <span class="n">corx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">corOptions</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">corOptions</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">corx</span> <span class="o">=</span> <span class="n">corx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">corOptions</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">useGenes</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">intType</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">corx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">corx</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">intType</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">corx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">corx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">elif</span> <span class="n">intType</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">corx</span><span class="p">[</span><span class="n">corx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">corx</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Some correlations are NA in block </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">startG</span><span class="p">)</span><span class="si">}</span><span class="s2"> : </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">endG</span><span class="p">)</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">corx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">useGenes</span><span class="p">]</span>

            <span class="n">corx</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">useGenes</span><span class="p">)))]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">datk_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nGenes1</span><span class="p">,</span> <span class="n">nPowers</span><span class="p">))</span>
            <span class="n">datk_local</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">corxPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">corx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">powerVector1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">powerVector1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">powerVector</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">powerSteps</span> <span class="o">=</span> <span class="n">powerVector</span> <span class="o">-</span> <span class="n">powerVector1</span>
            <span class="n">uniquePowerSteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">powerSteps</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">power</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">corx</span> <span class="o">**</span> <span class="n">power</span>

            <span class="n">corxPowers</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">uniquePowerSteps</span><span class="p">:</span>
                <span class="n">corxPowers</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPowers</span><span class="p">):</span>
                <span class="n">corxCur</span> <span class="o">=</span> <span class="n">corxPrev</span> <span class="o">*</span> <span class="n">corxPowers</span><span class="p">[</span><span class="n">powerSteps</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">datk_local</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">corxCur</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">corxPrev</span> <span class="o">=</span> <span class="n">corxCur</span>

            <span class="n">datk</span><span class="p">[</span><span class="n">startG</span><span class="p">:</span><span class="n">endG</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">datk_local</span>

            <span class="n">startG</span> <span class="o">=</span> <span class="n">endG</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">gcInterval</span> <span class="o">&lt;</span> <span class="n">startG</span> <span class="o">-</span> <span class="n">lastGC</span><span class="p">:</span>
                <span class="n">lastGC</span> <span class="o">=</span> <span class="n">startG</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">powerVector</span><span class="p">)):</span>
            <span class="n">khelp</span> <span class="o">=</span> <span class="n">datk</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">SFT1</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">scaleFreeFitIndex</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">khelp</span><span class="p">,</span> <span class="n">nBreaks</span><span class="o">=</span><span class="n">nBreaks</span><span class="p">)</span>
            <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;SFT.R.sq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SFT1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Rsquared.SFT&#39;</span><span class="p">]</span>
            <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;slope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SFT1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;slope.SFT&#39;</span><span class="p">]</span>
            <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;truncated R.sq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SFT1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;truncatedExponentialAdjRsquared&#39;</span><span class="p">]</span>
            <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;mean(k)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">khelp</span><span class="p">)</span>
            <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;median(k)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">statistics</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">khelp</span><span class="p">)</span>
            <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;max(k)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">khelp</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">moreNetworkConcepts</span><span class="p">:</span>
                <span class="n">Density</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">khelp</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nGenes</span> <span class="o">*</span> <span class="p">(</span><span class="n">nGenes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Density&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Density</span>
                <span class="n">Centralization</span> <span class="o">=</span> <span class="n">nGenes</span> <span class="o">*</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">khelp</span><span class="p">)</span> <span class="o">-</span> <span class="n">statistics</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">khelp</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="n">nGenes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nGenes</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Centralization&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Centralization</span>
                <span class="n">Heterogeneity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nGenes</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">khelp</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">khelp</span><span class="p">)</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">datout</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;Heterogeneity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Heterogeneity</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">datout</span><span class="p">)</span>

        <span class="c1"># detect threshold more than 0.9 by default</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">datout</span><span class="p">[</span><span class="s1">&#39;SFT.R.sq&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">RsquaredCut</span><span class="p">,</span> <span class="n">datout</span><span class="p">[</span><span class="s1">&#39;mean(k)&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">MeanCut</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">powerEstimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">powerVector</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2">Selected power to have scale free network is </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">powerEstimate</span><span class="p">)</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">datout</span><span class="p">[</span><span class="s1">&#39;SFT.R.sq&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">powerEstimate</span> <span class="o">=</span> <span class="n">powerVector</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKGREEN</span><span class="si">}</span><span class="s2">No power detected to have scale free network!</span><span class="se">\n</span><span class="s2">Found the best given power which is &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">powerEstimate</span><span class="p">)</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">powerEstimate</span><span class="p">,</span> <span class="n">datout</span></div>

<div class="viewcode-block" id="WGCNA.checkSimilarity"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.checkSimilarity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">checkSimilarity</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check similarity matrix format is correct</span>

<span class="sd">        :param adjMat: data we want to be checked</span>
<span class="sd">        :type adjMat: pandas dataframe</span>
<span class="sd">        :param min: minimum value to be allowed for data (default = 0)</span>
<span class="sd">        :type min: int</span>
<span class="sd">        :param max: maximum value to be allowed for data (default = 1)</span>
<span class="sd">        :type max: int</span>

<span class="sd">        :raises exit: if format is not correct</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">adjMat</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not two-dimensional&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">ele</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">adjMat</span><span class="p">)):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not numeric&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not square&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">adjMat</span> <span class="o">-</span> <span class="n">adjMat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not symmetric&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">adjMat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">min</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">adjMat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;some entries are not between&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span></div>

<div class="viewcode-block" id="WGCNA.calBlockSize"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.calBlockSize">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calBlockSize</span><span class="p">(</span><span class="n">matrixSize</span><span class="p">,</span> <span class="n">rectangularBlocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxMemoryAllocation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overheadFactor</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        find suitable block size for calculating soft power threshold</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">maxMemoryAllocation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxAlloc</span> <span class="o">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_AS</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maxAlloc</span> <span class="o">=</span> <span class="n">maxMemoryAllocation</span> <span class="o">/</span> <span class="mi">8</span>

        <span class="n">maxAlloc</span> <span class="o">=</span> <span class="n">maxAlloc</span> <span class="o">/</span> <span class="n">overheadFactor</span>

        <span class="k">if</span> <span class="n">rectangularBlocks</span><span class="p">:</span>
            <span class="n">blockSz</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">maxAlloc</span> <span class="o">/</span> <span class="n">matrixSize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blockSz</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">maxAlloc</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">matrixSize</span><span class="p">,</span> <span class="n">blockSz</span><span class="p">)</span></div>

    <span class="c1"># Calculation of fitting statistics for evaluating scale free topology fit.</span>
<div class="viewcode-block" id="WGCNA.scaleFreeFitIndex"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.scaleFreeFitIndex">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">scaleFreeFitIndex</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">nBreaks</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculates several indices (fitting statistics) for evaluating scale free topology fit.</span>

<span class="sd">        :param k: numeric list whose components contain non-negative values</span>
<span class="sd">        :type k: list</span>
<span class="sd">        :param nBreaks: (default = 10)</span>
<span class="sd">        :type nBreaks: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">k</span><span class="p">})</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;discretized_k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">nBreaks</span><span class="p">)</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;discretized_k&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># tapply(k, discretized_k, mean)</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">reset_index</span><span class="p">())</span>
        <span class="n">dk</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;discretized_k&#39;</span><span class="p">,</span> <span class="s1">&#39;dk&#39;</span><span class="p">]</span>
        <span class="n">p_dk</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;discretized_k&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>  <span class="c1"># as.vector(tapply(k, discretized.k, length)/length(k))</span>
        <span class="n">p_dk</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">p_dk</span><span class="o">.</span><span class="n">reset_index</span><span class="p">())</span>
        <span class="n">p_dk</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;discretized_k&#39;</span><span class="p">,</span> <span class="s1">&#39;p_dk&#39;</span><span class="p">]</span>
        <span class="n">breaks1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">stop</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="n">nBreaks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">breaks1</span><span class="p">)</span>
        <span class="n">dk2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">p_dk</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;discretized_k&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dk2</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;dk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dk2</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;p_dk&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;p_dk&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;p_dk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;log_dk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">])</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;log_p_dk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;p_dk&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-09</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;log_p_dk_10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;log_dk&#39;</span><span class="p">])</span>

        <span class="n">model1</span> <span class="o">=</span> <span class="n">ols</span><span class="p">(</span><span class="n">formula</span><span class="o">=</span><span class="s1">&#39;log_p_dk ~ log_dk&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">model2</span> <span class="o">=</span> <span class="n">ols</span><span class="p">(</span><span class="n">formula</span><span class="o">=</span><span class="s1">&#39;log_p_dk ~ log_dk + log_p_dk_10&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">dfout</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Rsquared.SFT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">model1</span><span class="o">.</span><span class="n">rsquared</span><span class="p">],</span>
                              <span class="s1">&#39;slope.SFT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">model1</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                              <span class="s1">&#39;truncatedExponentialAdjRsquared&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">model2</span><span class="o">.</span><span class="n">rsquared_adj</span><span class="p">]})</span>
        <span class="k">return</span> <span class="n">dfout</span></div>

<div class="viewcode-block" id="WGCNA.adjacency"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.adjacency">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">adjacency</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">selectCols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adjacencyType</span><span class="o">=</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">corOptions</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">weightArgNames</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates (correlation or distance) network adjacency from given expression data or from a similarity</span>

<span class="sd">        :param datExpr: data frame containing expression data. Columns correspond to genes and rows to samples.</span>
<span class="sd">        :type datExpr: pandas dataframe</span>
<span class="sd">        :param selectCols: for correlation networks only; can be used to select genes whose adjacencies will be calculated. Should be either a numeric list giving the indices of the genes to be used, or a boolean list indicating which genes are to be used.</span>
<span class="sd">        :type selectCols: list</span>
<span class="sd">        :param adjacencyType: adjacency network type. Allowed values are (unique abbreviations of) &quot;unsigned&quot;, &quot;signed&quot;, &quot;signed hybrid&quot;. (default = unsigned)</span>
<span class="sd">        :type adjacencyType: str</span>
<span class="sd">        :param power: soft thresholding power.</span>
<span class="sd">        :type power: int</span>
<span class="sd">        :param corOptions: specifying additional arguments to be passed to the function given by corFnc.</span>
<span class="sd">        :type corOptions: pandas dataframe</span>
<span class="sd">        :param weights: optional observation weights for datExpr to be used in correlation calculation. A matrix of the same dimensions as datExpr, containing non-negative weights. Only used with Pearson correlation.</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param weightArgNames: character list of length 2 giving the names of the arguments to corFnc that represent weights for variable x and y. Only used if weights are non-NULL.</span>
<span class="sd">        :type weightArgNames: list</span>

<span class="sd">        :return: Adjacency matrix</span>
<span class="sd">        :rtype: pandas dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">calculating adjacency matrix ...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weightArgNames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weightArgNames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;weights.x&quot;</span><span class="p">,</span> <span class="s2">&quot;weights.y&quot;</span><span class="p">]</span>
        <span class="n">intType</span> <span class="o">=</span> <span class="n">adjacencyTypes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">adjacencyType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intType</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Unrecognized &#39;type&#39;. Recognized values are&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">adjacencyTypes</span><span class="p">)))</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkAndScaleWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">datExpr</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">selectCols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corOptions</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">weightOpt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;weights.x&#39;</span><span class="p">:</span> <span class="n">weights</span><span class="p">})</span>
                    <span class="n">weightOpt</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">weightArgNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weightOpt</span> <span class="o">=</span> <span class="n">weightArgNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; = weights&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corOptions</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">weightOpt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;weights.x&#39;</span><span class="p">:</span> <span class="n">weights</span><span class="p">,</span> <span class="s1">&#39;weights.y&#39;</span><span class="p">:</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">selectCols</span><span class="p">]})</span>
                    <span class="n">weightOpt</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">weightArgNames</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weightOpt</span> <span class="o">=</span> <span class="n">weightArgNames</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; = weights, &quot;</span> <span class="o">+</span> <span class="n">weightArgNames</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; = weights[, selectCols]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corOptions</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">weightOpt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weightOpt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">selectCols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cor_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span>
                <span class="n">datExpr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># cor_mat = do.call(corFnc.fnc, c(list(x = datExpr), weightOpt, corOptions))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cor_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">datExpr</span><span class="p">[:,</span> <span class="n">selectCols</span><span class="p">])</span>  <span class="c1"># , weightOpt, corOptions)</span>

        <span class="k">if</span> <span class="n">intType</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cor_mat</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cor_mat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">intType</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cor_mat</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">cor_mat</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">intType</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cor_mat</span><span class="p">[</span><span class="n">cor_mat</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cor_mat</span> <span class="o">**</span> <span class="n">power</span></div>

<div class="viewcode-block" id="WGCNA.checkAdjMat"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.checkAdjMat">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">checkAdjMat</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        check adjacency matrix format is correct</span>

<span class="sd">        :param adjMat: data we want to be checked</span>
<span class="sd">        :type adjMat: pandas dataframe</span>
<span class="sd">        :param min: minimum value to be allowed for data (default = 0)</span>
<span class="sd">        :type min: int</span>
<span class="sd">        :param max: maximum value to be allowed for data (default = 1)</span>
<span class="sd">        :type max: int</span>

<span class="sd">        :raises exit: if format is not correct</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">adjMat</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not two-dimensional&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">adjMat</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not numeric&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not square&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="n">adjMat</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;adjacency is not symmetric&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">adjMat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">min</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">adjMat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;some entries are not between&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span></div>

<div class="viewcode-block" id="WGCNA.TomSimilarityFromAdj"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.TomSimilarityFromAdj">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">TomSimilarityFromAdj</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="n">TOMDenom</span><span class="p">,</span> <span class="n">TOMType</span><span class="p">):</span>
        <span class="c1"># Prepare adjacency</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Compute TOM</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="n">adjMat</span><span class="p">)</span>
        <span class="n">ki</span> <span class="o">=</span> <span class="n">adjMat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">kj</span> <span class="o">=</span> <span class="n">adjMat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">TOMDenom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># min</span>
            <span class="n">MINK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ki_</span><span class="p">,</span> <span class="n">kj</span><span class="p">)</span> <span class="k">for</span> <span class="n">ki_</span> <span class="ow">in</span> <span class="n">ki</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># mean</span>
            <span class="n">MINK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([((</span><span class="n">ki_</span> <span class="o">+</span> <span class="n">kj</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">ki_</span> <span class="ow">in</span> <span class="n">ki</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">TOMType</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># unsigned</span>
            <span class="n">tom</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="n">adjMat</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">MINK</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">adjMat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># signed</span>
            <span class="n">tom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">((</span><span class="n">L</span> <span class="o">+</span> <span class="n">adjMat</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">MINK</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">adjMat</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">tom</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tom</span></div>

<div class="viewcode-block" id="WGCNA.TOMsimilarity"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.TOMsimilarity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">TOMsimilarity</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="n">TOMType</span><span class="o">=</span><span class="s2">&quot;signed&quot;</span><span class="p">,</span> <span class="n">TOMDenom</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculation of the topological overlap matrix, and the corresponding dissimilarity, from a given adjacency matrix</span>

<span class="sd">        :param adjMat: adjacency matrix, that is a square, symmetric matrix with entries between 0 and 1 (negative values are allowed if TOMType==&quot;signed&quot;).</span>
<span class="sd">        :type adjMat: pandas dataframe</span>
<span class="sd">        :param TOMType: one of &quot;unsigned&quot;, &quot;signed&quot;</span>
<span class="sd">        :type TOMType: str</span>
<span class="sd">        :param TOMDenom: a character string specifying the TOM variant to be used. Recognized values are &quot;min&quot; giving the standard TOM described in Zhang and Horvath (2005), and &quot;mean&quot; in which the min function in the denominator is replaced by mean. The &quot;mean&quot; may produce better results but at this time should be considered experimental.</span>
<span class="sd">        :type TOMDenom: str</span>

<span class="sd">        :return: A matrix holding the topological overlap.</span>
<span class="sd">        :rtype: pandas dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TOMTypeC</span> <span class="o">=</span> <span class="n">TOMTypes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">TOMType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">TOMTypeC</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Invalid &#39;TOMType&#39;. Recognized values are&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">TOMTypes</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">TOMTypeC</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;&#39;TOMType&#39; cannot be &#39;none&#39; for this function.&quot;</span><span class="p">)</span>
        <span class="n">TOMDenomC</span> <span class="o">=</span> <span class="n">TOMDenoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">TOMDenom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">TOMDenomC</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Invalid &#39;TOMDenom&#39;. Recognized values are&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">TOMDenoms</span><span class="p">)))</span>

        <span class="nb">min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">TOMTypeC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkAdjMat</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">calculating TOM similarity matrix ...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">tom</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">TomSimilarityFromAdj</span><span class="p">(</span><span class="n">adjMat</span><span class="p">,</span> <span class="n">TOMDenomC</span><span class="p">,</span> <span class="n">TOMTypeC</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">tom</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.interpolate"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.interpolate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span></div>

<div class="viewcode-block" id="WGCNA.coreSizeFunc"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.coreSizeFunc">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">coreSizeFunc</span><span class="p">(</span><span class="n">BranchSize</span><span class="p">,</span> <span class="n">minClusterSize</span><span class="p">):</span>
        <span class="n">BaseCoreSize</span> <span class="o">=</span> <span class="n">minClusterSize</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">BaseCoreSize</span> <span class="o">&lt;</span> <span class="n">BranchSize</span><span class="p">:</span>
            <span class="n">CoreSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">BaseCoreSize</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">BranchSize</span> <span class="o">-</span> <span class="n">BaseCoreSize</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CoreSize</span> <span class="o">=</span> <span class="n">BranchSize</span>

        <span class="k">return</span> <span class="n">CoreSize</span></div>

<div class="viewcode-block" id="WGCNA.cutreeHybrid"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.cutreeHybrid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cutreeHybrid</span><span class="p">(</span><span class="n">dendro</span><span class="p">,</span> <span class="n">distM</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minClusterSize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">deepSplit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">maxCoreScatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minGap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxAbsCoreScatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">minAbsGap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minSplitHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minAbsSplitHeight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">externalBranchSplitFnc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nExternalSplits</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">minExternalSplit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">externalSplitOptions</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="n">externalSplitFncNeedsDistance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">assumeSimpleExternalSpecification</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pamStage</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">pamRespectsDendro</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useMedoids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxPamDist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">respectSmallClusters</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect clusters in a dendorgram produced by the function hclust.</span>

<span class="sd">        :param dendro: a hierarchical clustering dendorgram such as one returned by hclust.</span>
<span class="sd">        :type dendro: ndarray</span>
<span class="sd">        :param distM: Distance matrix that was used as input to hclust.</span>
<span class="sd">        :type distM: pandas dataframe</span>
<span class="sd">        :param cutHeight: Maximum joining heights that will be considered. It defaults to 99of the range between the 5th percentile and the maximum of the joining heights on the dendrogram.</span>
<span class="sd">        :type cutHeight: int</span>
<span class="sd">        :param minClusterSize: Minimum cluster size. (default = 20)</span>
<span class="sd">        :type minClusterSize: int</span>
<span class="sd">        :param deepSplit: Either logical or integer in the range 0 to 4. Provides a rough control over sensitivity to cluster splitting. The higher the value, the more and smaller clusters will be produced. (default = 1)</span>
<span class="sd">        :type deepSplit: int or bool</span>
<span class="sd">        :param maxCoreScatter: Maximum scatter of the core for a branch to be a cluster, given as the fraction of cutHeight relative to the 5th percentile of joining heights.</span>
<span class="sd">        :type maxCoreScatter: int</span>
<span class="sd">        :param minGap: Minimum cluster gap given as the fraction of the difference between cutHeight and the 5th percentile of joining heights.</span>
<span class="sd">        :type minGap: int</span>
<span class="sd">        :param maxAbsCoreScatter: Maximum scatter of the core for a branch to be a cluster given as absolute heights. If given, overrides maxCoreScatter.</span>
<span class="sd">        :type maxAbsCoreScatter: int</span>
<span class="sd">        :param minAbsGap: Minimum cluster gap given as absolute height difference. If given, overrides minGap.</span>
<span class="sd">        :type minAbsGap: int</span>
<span class="sd">        :param minSplitHeight: Minimum split height given as the fraction of the difference between cutHeight and the 5th percentile of joining heights. Branches merging below this height will automatically be merged. Defaults to zero but is used only if minAbsSplitH</span>
<span class="sd">        :type minSplitHeight: int</span>
<span class="sd">        :param minAbsSplitHeight: Minimum split height given as an absolute height. Branches merging below this height will automatically be merged. If not given (default), will be determined from minSplitHeight above.</span>
<span class="sd">        :type minAbsSplitHeight: int</span>
<span class="sd">        :param externalBranchSplitFnc: Optional function to evaluate split (dissimilarity) between two branches. Either a single function or a list in which each component is a function.</span>

<span class="sd">        :param minExternalSplit: Thresholds to decide whether two branches should be merged. It should be a numeric list of the same length as the number of functions in externalBranchSplitFnc above.</span>
<span class="sd">        :type minExternalSplit: list</span>
<span class="sd">        :param externalSplitOptions: Further arguments to function externalBranchSplitFnc. If only one external function is specified in externalBranchSplitFnc above, externalSplitOptions can be a named list of arguments or a list with one component.</span>
<span class="sd">        :type externalSplitOptions: pandas dataframe</span>
<span class="sd">        :param externalSplitFncNeedsDistance: Optional specification of whether the external branch split functions need the distance matrix as one of their arguments. Either NULL or a logical list with one element per branch</span>
<span class="sd">        :type externalSplitFncNeedsDistance: pandas dataframe</span>
<span class="sd">        :param assumeSimpleExternalSpecification: when minExternalSplit above is a scalar (has length 1), should the function assume a simple specification of externalBranchSplitFnc and externalSplitOptions. (default = True)</span>
<span class="sd">        :type assumeSimpleExternalSpecification: bool</span>
<span class="sd">        :param pamStage: If TRUE, the second (PAM-like) stage will be performed. (default = True)</span>
<span class="sd">        :type pamStage: bool</span>
<span class="sd">        :param pamRespectsDendro: If TRUE, the PAM stage will respect the dendrogram in the sense an object can be PAM-assigned only to clusters that lie below it on the branch that the object is merged into. (default = True)</span>
<span class="sd">        :type pamRespectsDendro: bool</span>
<span class="sd">        :param useMedoids: if TRUE, the second stage will be use object to medoid distance; if FALSE, it will use average object to cluster distance. (default = False)</span>
<span class="sd">        :param maxPamDist: Maximum object distance to closest cluster that will result in the object assigned to that cluster. Defaults to cutHeight.</span>
<span class="sd">        :type maxPamDist: float</span>
<span class="sd">        :param respectSmallClusters: If TRUE, branches that failed to be clusters in stage 1 only because of insufficient size will be assigned together in stage 2. If FALSE, all objects will be assigned individually. (default = False)</span>
<span class="sd">        :type respectSmallClusters: bool</span>

<span class="sd">        :return: list detailing the deteced branch structure.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dendro</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dendro</span><span class="p">[</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dendro</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dendro</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dendro</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dendro</span><span class="p">[</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dendro</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dendro</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">chunkSize</span> <span class="o">=</span> <span class="n">dendro</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">maxPamDist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxPamDist</span> <span class="o">=</span> <span class="n">cutHeight</span>

        <span class="n">nMerge</span> <span class="o">=</span> <span class="n">dendro</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nMerge</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;The given dendrogram is suspicious: number of merges is zero.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;distM must be non-NULL&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distM</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;distM must be a matrix.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nMerge</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">distM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nMerge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;distM has incorrect dimensions.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pamRespectsDendro</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">respectSmallClusters</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cutreeHybrid Warning: parameters pamRespectsDendro (TRUE) &quot;</span>
                  <span class="s2">&quot;and respectSmallClusters (FALSE) imply contradictory intent.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="s2">&quot;Although the code will work, please check you really intented &quot;</span>
                  <span class="s2">&quot;these settings for the two arguments.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">Going through the merge tree...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">distM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">distM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">refQuantile</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="n">refMerge</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">nMerge</span> <span class="o">*</span> <span class="n">refQuantile</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">refMerge</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">refMerge</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">refHeight</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">refMerge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cutHeight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutHeight</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dendro</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">refHeight</span><span class="p">)</span> <span class="o">+</span> <span class="n">refHeight</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;..cutHeight not given, setting it to&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">cutHeight</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                  <span class="s2">&quot; ===&gt;  99</span><span class="si">% o</span><span class="s2">f the (truncated) height range in dendro.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cutHeight</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dendro</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]):</span>
                <span class="n">cutHeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dendro</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">maxPamDist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxPamDist</span> <span class="o">=</span> <span class="n">cutHeight</span>
        <span class="n">nMergeBelowCut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">dendro</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cutHeight</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nMergeBelowCut</span> <span class="o">&lt;</span> <span class="n">minClusterSize</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cutHeight set too low: no merges below the cut.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nMerge</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)})</span>

        <span class="k">if</span> <span class="n">externalBranchSplitFnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nExternalSplits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">externalBranchSplitFnc</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">minExternalSplit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;&#39;minExternalBranchSplit&#39; must be given.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">assumeSimpleExternalSpecification</span> <span class="ow">and</span> <span class="n">nExternalSplits</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">externalSplitOptions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">externalSplitOptions</span><span class="p">)</span>
            <span class="c1"># TODO: externalBranchSplitFnc = lapply(externalBranchSplitFnc, match.fun)</span>
            <span class="k">for</span> <span class="n">es</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nExternalSplits</span><span class="p">):</span>
                <span class="n">externalSplitOptions</span><span class="p">[</span><span class="s1">&#39;tree&#39;</span><span class="p">][</span><span class="n">es</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">externalSplitFncNeedsDistance</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">externalSplitFncNeedsDistance</span><span class="p">[</span><span class="n">es</span><span class="p">]:</span>
                    <span class="n">externalSplitOptions</span><span class="p">[</span><span class="s1">&#39;dissimMat&#39;</span><span class="p">][</span><span class="n">es</span><span class="p">]</span> <span class="o">=</span> <span class="n">distM</span>

        <span class="n">MxBranches</span> <span class="o">=</span> <span class="n">nMergeBelowCut</span>
        <span class="n">branch_isBasic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_isTopBasic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_failSize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_rootHeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_nMerge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_nSingletons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_nBasicClusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_mergedInto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_attachHeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">MxBranches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">branch_singletons</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">branch_basicClusters</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">branch_mergingHeights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">branch_singletonHeights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">nBranches</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">defMCS</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.64</span><span class="p">,</span> <span class="mf">0.73</span><span class="p">,</span> <span class="mf">0.82</span><span class="p">,</span> <span class="mf">0.91</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">]</span>
        <span class="n">defMG</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">defMC</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3.0</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="k">for</span> <span class="n">defMC</span> <span class="ow">in</span> <span class="n">defMCS</span><span class="p">]</span>
        <span class="n">nSplitDefaults</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">defMCS</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deepSplit</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">deepSplit</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">deepSplit</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nSplitDefaults</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deepSplit</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">deepSplit</span> <span class="o">&gt;</span> <span class="n">nSplitDefaults</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameter deepSplit (value&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">deepSplit</span><span class="p">)</span> <span class="o">+</span> \
                  <span class="s2">&quot;) out of range: allowable range is 0 through&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">nSplitDefaults</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxCoreScatter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxCoreScatter</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">defMCS</span><span class="p">,</span> <span class="n">deepSplit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minGap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minGap</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">defMG</span><span class="p">,</span> <span class="n">deepSplit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxAbsCoreScatter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxAbsCoreScatter</span> <span class="o">=</span> <span class="n">refHeight</span> <span class="o">+</span> <span class="n">maxCoreScatter</span> <span class="o">*</span> <span class="p">(</span><span class="n">cutHeight</span> <span class="o">-</span> <span class="n">refHeight</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minAbsGap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minAbsGap</span> <span class="o">=</span> <span class="n">minGap</span> <span class="o">*</span> <span class="p">(</span><span class="n">cutHeight</span> <span class="o">-</span> <span class="n">refHeight</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minSplitHeight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minSplitHeight</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">minAbsSplitHeight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minAbsSplitHeight</span> <span class="o">=</span> <span class="n">refHeight</span> <span class="o">+</span> <span class="n">minSplitHeight</span> <span class="o">*</span> <span class="p">(</span><span class="n">cutHeight</span> <span class="o">-</span> <span class="n">refHeight</span><span class="p">)</span>
        <span class="n">nPoints</span> <span class="o">=</span> <span class="n">nMerge</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">IndMergeToBranch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">onBranch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nPoints</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">RootBranch</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">mergeDiagnostics</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;smI&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;smSize&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;smCrSc&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;smGap&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;lgI&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;lgSize&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;lgCrSc&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;lgGap&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                         <span class="s1">&#39;merged&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">nMerge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)})</span>
        <span class="k">if</span> <span class="n">externalBranchSplitFnc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">externalMergeDiags</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nMerge</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nExternalSplits</span><span class="p">)))</span>

        <span class="n">extender</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">chunkSize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">merge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nMerge</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cutHeight</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nBranches</span> <span class="o">=</span> <span class="n">nBranches</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">branch_isTopBasic</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">branch_singletons</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">extender</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">branch_basicClusters</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span> <span class="n">extender</span><span class="p">)</span>
                    <span class="n">branch_mergingHeights</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">extender</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">branch_singletonHeights</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">extender</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="n">nBranches</span>
                    <span class="n">RootBranch</span> <span class="o">=</span> <span class="n">nBranches</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">clust</span> <span class="o">=</span> <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">clust</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Internal error: a previous merge has no associated cluster. Sorry!&quot;</span><span class="p">)</span>

                    <span class="n">gene</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">ns</span> <span class="o">=</span> <span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span>
                    <span class="n">nm</span> <span class="o">=</span> <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">clust</span><span class="p">]:</span>
                        <span class="n">branch_singletons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ns</span><span class="p">,</span> <span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">gene</span>
                        <span class="n">branch_singletonHeights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ns</span><span class="p">,</span> <span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">onBranch</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">gene</span><span class="p">)]</span> <span class="o">=</span> <span class="n">clust</span>

                    <span class="n">branch_mergingHeights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nm</span><span class="p">,</span> <span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="n">branch_size</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">nm</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="n">clust</span>
                    <span class="n">RootBranch</span> <span class="o">=</span> <span class="n">clust</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">clusts</span> <span class="o">=</span> <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">sizes</span> <span class="o">=</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">clusts</span><span class="p">]</span>
                    <span class="n">rnk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
                    <span class="n">small</span> <span class="o">=</span> <span class="n">clusts</span><span class="p">[</span><span class="n">rnk</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">large</span> <span class="o">=</span> <span class="n">clusts</span><span class="p">[</span><span class="n">rnk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">sizes</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">rnk</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]:</span>
                        <span class="n">coresize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">coreSizeFunc</span><span class="p">(</span><span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">small</span><span class="p">],</span> <span class="n">minClusterSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">Core</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">coresize</span><span class="p">,</span> <span class="n">small</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">Core</span> <span class="o">=</span> <span class="n">Core</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">SmAveDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Core</span><span class="p">,</span> <span class="n">Core</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">coresize</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">SmAveDist</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">]:</span>
                        <span class="n">coresize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">coreSizeFunc</span><span class="p">(</span><span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">large</span><span class="p">],</span> <span class="n">minClusterSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">Core</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">coresize</span><span class="p">,</span> <span class="n">large</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">Core</span> <span class="o">=</span> <span class="n">Core</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">LgAveDist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Core</span><span class="p">,</span> <span class="n">Core</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">coresize</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LgAveDist</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">mergeDiagnostics</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">small</span><span class="p">,</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">small</span><span class="p">],</span> <span class="n">SmAveDist</span><span class="p">,</span>
                                                      <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">SmAveDist</span><span class="p">,</span>
                                                      <span class="n">large</span><span class="p">,</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">large</span><span class="p">],</span> <span class="n">LgAveDist</span><span class="p">,</span>
                                                      <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">LgAveDist</span><span class="p">,</span>
                                                      <span class="kc">None</span><span class="p">]</span>
                    <span class="n">SmallerScores</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">],</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minClusterSize</span><span class="p">,</span>
                                     <span class="n">SmAveDist</span> <span class="o">&gt;</span> <span class="n">maxAbsCoreScatter</span><span class="p">,</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">SmAveDist</span> <span class="o">&lt;</span> <span class="n">minAbsGap</span><span class="p">,</span>
                                     <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minAbsSplitHeight</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">SmallerScores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">SmallerScores</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">DoMerge</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">SmallerFailSize</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">SmallerScores</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">SmallerScores</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LargerScores</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">],</span>
                                        <span class="n">branch_size</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minClusterSize</span><span class="p">,</span> <span class="n">LgAveDist</span> <span class="o">&gt;</span> <span class="n">maxAbsCoreScatter</span><span class="p">,</span>
                                        <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">LgAveDist</span> <span class="o">&lt;</span> <span class="n">minAbsGap</span><span class="p">,</span>
                                        <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minAbsSplitHeight</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">LargerScores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">LargerScores</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">DoMerge</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">SmallerFailSize</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">LargerScores</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|</span> <span class="n">LargerScores</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">small</span>
                            <span class="n">small</span> <span class="o">=</span> <span class="n">large</span>
                            <span class="n">large</span> <span class="o">=</span> <span class="n">x</span>
                            <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">DoMerge</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">if</span> <span class="n">DoMerge</span><span class="p">:</span>
                        <span class="n">mergeDiagnostics</span><span class="p">[</span><span class="s1">&#39;merged&#39;</span><span class="p">][</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">DoMerge</span> <span class="ow">and</span> <span class="n">nExternalSplits</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="ow">and</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">]:</span>
                        <span class="n">branch1</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="p">[[</span><span class="n">large</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="n">branch2</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="p">[[</span><span class="n">small</span><span class="p">]][</span><span class="mi">0</span><span class="p">:</span><span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="n">es</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">while</span> <span class="n">es</span> <span class="o">&lt;</span> <span class="n">nExternalSplits</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">DoMerge</span><span class="p">:</span>
                            <span class="n">es</span> <span class="o">=</span> <span class="n">es</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">args</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;externalSplitOptions&#39;</span><span class="p">:</span> <span class="n">externalSplitOptions</span><span class="p">[[</span><span class="n">es</span><span class="p">]],</span>
                                                 <span class="s1">&#39;branch1&#39;</span><span class="p">:</span> <span class="n">branch1</span><span class="p">,</span> <span class="s1">&#39;branch2&#39;</span><span class="p">:</span> <span class="n">branch2</span><span class="p">})</span>
                            <span class="c1"># TODO: extSplit = do.call(externalBranchSplitFnc[[es]], args)</span>
                            <span class="n">extSplit</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="n">DoMerge</span> <span class="o">=</span> <span class="n">extSplit</span> <span class="o">&lt;</span> <span class="n">minExternalSplit</span><span class="p">[</span><span class="n">es</span><span class="p">]</span>
                            <span class="n">externalMergeDiags</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="n">es</span><span class="p">]</span> <span class="o">=</span> <span class="n">extSplit</span>
                            <span class="n">mergeDiagnostics</span><span class="p">[</span><span class="s1">&#39;merged&#39;</span><span class="p">][</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="k">if</span> <span class="n">DoMerge</span><span class="p">:</span>
                                <span class="n">mergeDiagnostics</span><span class="p">[</span><span class="s1">&#39;merged&#39;</span><span class="p">][</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

                    <span class="k">if</span> <span class="n">DoMerge</span><span class="p">:</span>
                        <span class="n">branch_failSize</span><span class="p">[[</span><span class="n">small</span><span class="p">]]</span> <span class="o">=</span> <span class="n">SmallerFailSize</span>
                        <span class="n">branch_mergedInto</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">large</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">branch_attachHeight</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="n">branch_isTopBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">nss</span> <span class="o">=</span> <span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">nsl</span> <span class="o">=</span> <span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">large</span><span class="p">]</span>
                        <span class="n">ns</span> <span class="o">=</span> <span class="n">nss</span> <span class="o">+</span> <span class="n">nsl</span>
                        <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">]:</span>
                            <span class="n">branch_singletons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nsl</span><span class="p">:</span><span class="n">ns</span><span class="p">,</span> <span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nss</span><span class="p">,</span> <span class="n">small</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                            <span class="n">branch_singletonHeights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nsl</span><span class="p">:</span><span class="n">ns</span><span class="p">,</span> <span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_singletonHeights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nss</span><span class="p">,</span>
                                                                         <span class="n">small</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                            <span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]:</span>
                                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Internal error: merging two composite clusters. Sorry!&quot;</span><span class="p">)</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="p">[[</span><span class="n">small</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="n">onBranch</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">large</span> <span class="o">+</span> <span class="mi">1</span>

                        <span class="n">nm</span> <span class="o">=</span> <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">large</span><span class="p">]</span>
                        <span class="n">branch_mergingHeights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nm</span><span class="p">,</span> <span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">nm</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">branch_size</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">large</span><span class="p">]</span>
                        <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="n">large</span>
                        <span class="n">RootBranch</span> <span class="o">=</span> <span class="n">large</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">large</span>
                            <span class="n">large</span> <span class="o">=</span> <span class="n">small</span>
                            <span class="n">small</span> <span class="o">=</span> <span class="n">x</span>
                            <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pamStage</span> <span class="ow">and</span> <span class="n">pamRespectsDendro</span><span class="p">):</span>
                            <span class="n">nBranches</span> <span class="o">=</span> <span class="n">nBranches</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">branch_attachHeight</span><span class="p">[[</span><span class="n">large</span><span class="p">,</span> <span class="n">small</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">branch_mergedInto</span><span class="p">[[</span><span class="n">large</span><span class="p">,</span> <span class="n">small</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nBranches</span>
                            <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]:</span>
                                <span class="n">addBasicClusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">addBasicClusters</span> <span class="o">=</span> <span class="n">branch_basicClusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                    <span class="p">(</span><span class="n">branch_basicClusters</span><span class="p">[[</span><span class="n">small</span><span class="p">]]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">small</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">large</span><span class="p">]:</span>
                                <span class="n">addBasicClusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">addBasicClusters</span><span class="p">,</span> <span class="p">[</span><span class="n">large</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">addBasicClusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">addBasicClusters</span><span class="p">,</span>
                                                                   <span class="n">branch_basicClusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span>
                                                                                                    <span class="n">branch_basicClusters</span><span class="p">[</span>
                                                                                                        <span class="p">[</span>
                                                                                                            <span class="n">large</span><span class="p">]]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                                                                       <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">large</span><span class="p">]),</span>
                                                                  <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">branch_isTopBasic</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">branch_basicClusters</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span>
                                                        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">addBasicClusters</span><span class="p">,</span>
                                                                        <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                                                                  <span class="n">chunkSize</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">addBasicClusters</span><span class="p">))),</span>
                                                                       <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                            <span class="n">branch_singletons</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">chunkSize</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
                            <span class="n">branch_singletonHeights</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">chunkSize</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
                            <span class="n">branch_mergingHeights</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">nBranches</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">,</span>
                                                         <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">extender</span><span class="p">),</span>
                                                                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                            <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                            <span class="n">branch_size</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
                            <span class="n">branch_nBasicClusters</span><span class="p">[</span><span class="n">nBranches</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">addBasicClusters</span><span class="p">)</span>
                            <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="n">nBranches</span>
                            <span class="n">RootBranch</span> <span class="o">=</span> <span class="n">nBranches</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">branch_isBasic</span><span class="p">[</span><span class="n">small</span><span class="p">]:</span>
                                <span class="n">addBasicClusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">addBasicClusters</span> <span class="o">=</span> <span class="n">branch_basicClusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                                    <span class="p">(</span><span class="n">branch_basicClusters</span><span class="p">[[</span><span class="n">small</span><span class="p">]]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">small</span><span class="p">]</span>

                            <span class="n">nbl</span> <span class="o">=</span> <span class="n">branch_nBasicClusters</span><span class="p">[</span><span class="n">large</span><span class="p">]</span>
                            <span class="n">nb</span> <span class="o">=</span> <span class="n">branch_nBasicClusters</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">addBasicClusters</span><span class="p">)</span>
                            <span class="n">branch_basicClusters</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">nbl</span><span class="p">:</span><span class="n">nb</span><span class="p">,</span> <span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">addBasicClusters</span>
                            <span class="n">branch_nBasicClusters</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb</span>
                            <span class="n">branch_size</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">small</span><span class="p">]</span>
                            <span class="n">nm</span> <span class="o">=</span> <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">branch_mergingHeights</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nm</span><span class="p">,</span> <span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">branch_nMerge</span><span class="p">[</span><span class="n">large</span><span class="p">]</span> <span class="o">=</span> <span class="n">nm</span>
                            <span class="n">branch_attachHeight</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">dendro</span><span class="p">[</span><span class="n">merge</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                            <span class="n">branch_mergedInto</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">=</span> <span class="n">large</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="n">IndMergeToBranch</span><span class="p">[</span><span class="n">merge</span><span class="p">]</span> <span class="o">=</span> <span class="n">large</span>
                            <span class="n">RootBranch</span> <span class="o">=</span> <span class="n">large</span>

        <span class="n">nBranches</span> <span class="o">=</span> <span class="n">nBranches</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">isCluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">nBranches</span><span class="p">)</span>
        <span class="n">SmallLabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nPoints</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nBranches</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">branch_attachHeight</span><span class="p">[</span><span class="n">clust</span><span class="p">]):</span>
                <span class="n">branch_attachHeight</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">cutHeight</span>
            <span class="k">if</span> <span class="n">branch_isTopBasic</span><span class="p">[</span><span class="n">clust</span><span class="p">]:</span>
                <span class="n">coresize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">coreSizeFunc</span><span class="p">(</span><span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">clust</span><span class="p">],</span> <span class="n">minClusterSize</span><span class="p">)</span>
                <span class="n">Core</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">coresize</span><span class="p">,</span> <span class="n">clust</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">Core</span> <span class="o">=</span> <span class="n">Core</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">CoreScatter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Core</span><span class="p">,</span> <span class="n">Core</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">coresize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">isCluster</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">branch_isTopBasic</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="ow">and</span> <span class="n">branch_size</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minClusterSize</span> <span class="ow">and</span>
                                    <span class="n">CoreScatter</span> <span class="o">&lt;</span> <span class="n">maxAbsCoreScatter</span> <span class="ow">and</span> <span class="n">branch_attachHeight</span><span class="p">[</span>
                                        <span class="n">clust</span><span class="p">]</span> <span class="o">-</span> <span class="n">CoreScatter</span> <span class="o">&gt;</span> <span class="n">minAbsGap</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">CoreScatter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">branch_failSize</span><span class="p">[</span><span class="n">clust</span><span class="p">]:</span>
                <span class="n">SmallLabels</span><span class="p">[</span><span class="n">branch_singletons</span><span class="p">[[</span><span class="n">clust</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">clust</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">respectSmallClusters</span><span class="p">:</span>
            <span class="n">SmallLabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nPoints</span><span class="p">)</span>

        <span class="n">Colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nPoints</span><span class="p">,))</span>
        <span class="n">coreLabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nPoints</span><span class="p">,))</span>
        <span class="n">clusterBranches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">isCluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">branchLabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBranches</span><span class="p">,))</span>
        <span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">clust</span> <span class="ow">in</span> <span class="n">clusterBranches</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">color</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="p">[[</span><span class="n">clust</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">Colors</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
            <span class="n">SmallLabels</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">coresize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">coreSizeFunc</span><span class="p">(</span><span class="n">branch_nSingletons</span><span class="p">[</span><span class="n">clust</span><span class="p">],</span> <span class="n">minClusterSize</span><span class="p">)</span>
            <span class="n">Core</span> <span class="o">=</span> <span class="n">branch_singletons</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">coresize</span><span class="p">,</span> <span class="n">clust</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">Core</span> <span class="o">=</span> <span class="n">Core</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">coreLabels</span><span class="p">[</span><span class="n">Core</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
            <span class="n">branchLabels</span><span class="p">[</span><span class="n">clust</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

        <span class="n">Labeled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">Unlabeled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">nUnlabeled</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unlabeled</span><span class="p">)</span>
        <span class="n">UnlabeledExist</span> <span class="o">=</span> <span class="n">nUnlabeled</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Labeled</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">LabelFac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">Colors</span><span class="p">[</span><span class="n">Labeled</span><span class="p">])</span>
            <span class="n">nProperLabels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">LabelFac</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nProperLabels</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">pamStage</span> <span class="ow">and</span> <span class="n">UnlabeledExist</span> <span class="ow">and</span> <span class="n">nProperLabels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nPAMed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">useMedoids</span><span class="p">:</span>
                <span class="n">Medoids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nProperLabels</span><span class="p">)</span>
                <span class="n">ClusterRadii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nProperLabels</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nProperLabels</span><span class="p">):</span>
                    <span class="n">InCluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">DistInCluster</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">InCluster</span><span class="p">,</span> <span class="n">InCluster</span><span class="p">]</span>
                    <span class="n">DistSums</span> <span class="o">=</span> <span class="n">DistInCluster</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">Medoids</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">InCluster</span><span class="p">[</span><span class="n">DistSums</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]</span>
                    <span class="n">ClusterRadii</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">DistInCluster</span><span class="p">[:,</span> <span class="n">DistSums</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()])</span>

                <span class="k">if</span> <span class="n">respectSmallClusters</span><span class="p">:</span>
                    <span class="n">FSmallLabels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">SmallLabels</span><span class="p">)</span>
                    <span class="n">SmallLabLevs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">FSmallLabels</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
                    <span class="n">nSmallClusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">FSmallLabels</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">SmallLabLevs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">nSmallClusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">sclust</span> <span class="ow">in</span> <span class="n">SmallLabLevs</span><span class="p">[</span><span class="n">SmallLabLevs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]:</span>
                            <span class="n">InCluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">SmallLabels</span> <span class="o">==</span> <span class="n">sclust</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">pamRespectsDendro</span><span class="p">:</span>
                                <span class="n">onBr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">onBranch</span><span class="p">[</span><span class="n">InCluster</span><span class="p">])</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">onBr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Internal error: objects in a small cluster are marked to belong</span><span class="se">\n</span><span class="s2"> &quot;</span> \
                                          <span class="s2">&quot;to several large branches:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">onBr</span><span class="p">)</span>
                                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                                <span class="k">if</span> <span class="n">onBr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">basicOnBranch</span> <span class="o">=</span> <span class="n">branch_basicClusters</span><span class="p">[[</span><span class="n">onBr</span><span class="p">]]</span>
                                    <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="n">branchLabels</span><span class="p">[</span><span class="n">basicOnBranch</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="kc">None</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nProperLabels</span><span class="p">))</span>

                            <span class="n">DistInCluster</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">InCluster</span><span class="p">,</span> <span class="n">InCluster</span><span class="p">]</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labelsOnBranch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">InCluster</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">DistSums</span> <span class="o">=</span> <span class="n">DistInCluster</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="n">smed</span> <span class="o">=</span> <span class="n">InCluster</span><span class="p">[</span><span class="n">DistSums</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]</span>
                                    <span class="n">DistToMeds</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Medoids</span><span class="p">[</span><span class="n">labelsOnBranch</span><span class="p">],</span> <span class="n">smed</span><span class="p">]</span>
                                    <span class="n">closest</span> <span class="o">=</span> <span class="n">DistToMeds</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
                                    <span class="n">DistToClosest</span> <span class="o">=</span> <span class="n">DistToMeds</span><span class="p">[</span><span class="n">closest</span><span class="p">]</span>
                                    <span class="n">closestLabel</span> <span class="o">=</span> <span class="n">labelsOnBranch</span><span class="p">[</span><span class="n">closest</span><span class="p">]</span>
                                    <span class="k">if</span> <span class="n">DistToClosest</span> <span class="o">&lt;</span> <span class="n">ClusterRadii</span><span class="p">[</span><span class="n">closestLabel</span><span class="p">]</span> <span class="ow">or</span> <span class="n">DistToClosest</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">:</span>
                                        <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">closestLabel</span>
                                        <span class="n">nPAMed</span> <span class="o">=</span> <span class="n">nPAMed</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">InCluster</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">Unlabeled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unlabeled</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">Unlabeled</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pamRespectsDendro</span><span class="p">:</span>
                            <span class="n">onBr</span> <span class="o">=</span> <span class="n">onBranch</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">onBr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">basicOnBranch</span> <span class="o">=</span> <span class="n">branch_basicClusters</span><span class="p">[[</span><span class="n">onBr</span><span class="p">]]</span>
                                <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="n">branchLabels</span><span class="p">[</span><span class="n">basicOnBranch</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nProperLabels</span><span class="p">))</span>

                        <span class="k">if</span> <span class="n">labelsOnBranch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">UnassdToMedoidDist</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Medoids</span><span class="p">[</span><span class="n">labelsOnBranch</span><span class="p">],</span> <span class="n">obj</span><span class="p">]</span>
                            <span class="n">nearest</span> <span class="o">=</span> <span class="n">UnassdToMedoidDist</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
                            <span class="n">NearestCenterDist</span> <span class="o">=</span> <span class="n">UnassdToMedoidDist</span><span class="p">[</span><span class="n">nearest</span><span class="p">]</span>
                            <span class="n">nearestMed</span> <span class="o">=</span> <span class="n">labelsOnBranch</span><span class="p">[</span><span class="n">nearest</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">NearestCenterDist</span> <span class="o">&lt;</span> <span class="n">ClusterRadii</span><span class="p">[</span><span class="n">nearestMed</span><span class="p">]</span> <span class="ow">or</span> <span class="n">NearestCenterDist</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">:</span>
                                <span class="n">Colors</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearestMed</span>
                                <span class="n">nPAMed</span> <span class="o">=</span> <span class="n">nPAMed</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">UnlabeledExist</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ClusterDiam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nProperLabels</span><span class="p">,))</span>
                <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nProperLabels</span><span class="p">):</span>
                    <span class="n">InCluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="p">(</span><span class="n">cluster</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">nInCluster</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">InCluster</span><span class="p">)</span>
                    <span class="n">DistInCluster</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">InCluster</span><span class="p">,</span> <span class="n">InCluster</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">nInCluster</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">AveDistInClust</span> <span class="o">=</span> <span class="n">DistInCluster</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nInCluster</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">AveDistInClust</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">AveDistInClust</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">ColorsX</span> <span class="o">=</span> <span class="n">Colors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">respectSmallClusters</span><span class="p">:</span>
                    <span class="n">FSmallLabels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">SmallLabels</span><span class="p">)</span>
                    <span class="n">SmallLabLevs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">FSmallLabels</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
                    <span class="n">nSmallClusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">FSmallLabels</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">SmallLabLevs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nSmallClusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pamRespectsDendro</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">sclust</span> <span class="ow">in</span> <span class="n">SmallLabLevs</span><span class="p">[</span><span class="n">SmallLabLevs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]:</span>
                                <span class="n">InCluster</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nPoints</span><span class="p">))[</span><span class="n">SmallLabels</span> <span class="o">==</span> <span class="n">sclust</span><span class="p">]</span>
                                <span class="n">onBr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">onBranch</span><span class="p">[</span><span class="n">InCluster</span><span class="p">])</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">onBr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Internal error: objects in a small cluster are marked to belong</span><span class="se">\n</span><span class="s2">&quot;</span> \
                                          <span class="s2">&quot;to several large branches:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">onBr</span><span class="p">)</span>
                                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">onBr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">basicOnBranch</span> <span class="o">=</span> <span class="n">branch_basicClusters</span><span class="p">[[</span><span class="n">onBr</span><span class="p">]]</span>
                                    <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="n">branchLabels</span><span class="p">[</span><span class="n">basicOnBranch</span><span class="p">]</span>
                                    <span class="n">useObjects</span> <span class="o">=</span> <span class="n">ColorsX</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelsOnBranch</span><span class="p">)</span>
                                    <span class="n">DistSClustClust</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">InCluster</span><span class="p">,</span> <span class="n">useObjects</span><span class="p">]</span>
                                    <span class="n">MeanDist</span> <span class="o">=</span> <span class="n">DistSClustClust</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                    <span class="n">useColorsFac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">ColorsX</span><span class="p">[</span><span class="n">useObjects</span><span class="p">])</span>
                                    <span class="c1"># TODO</span>
                                    <span class="n">MeanMeanDist</span> <span class="o">=</span> <span class="n">MeanDist</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                                        <span class="s1">&#39;useColorsFac&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># tapply(MeanDist, useColorsFac, mean)</span>
                                    <span class="n">nearest</span> <span class="o">=</span> <span class="n">MeanMeanDist</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
                                    <span class="n">NearestDist</span> <span class="o">=</span> <span class="n">MeanMeanDist</span><span class="p">[</span><span class="n">nearest</span><span class="p">]</span>
                                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NearestDist</span> <span class="o">&lt;</span> <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">nearest</span><span class="p">]),</span>
                                                     <span class="n">NearestDist</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                                        <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest</span>
                                        <span class="n">nPAMed</span> <span class="o">=</span> <span class="n">nPAMed</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">InCluster</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nProperLabels</span><span class="p">))</span>
                            <span class="n">useObjects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ColorsX</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">sclust</span> <span class="ow">in</span> <span class="n">SmallLabLevs</span><span class="p">[</span><span class="n">SmallLabLevs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]:</span>
                                <span class="n">InCluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">SmallLabels</span> <span class="o">==</span> <span class="n">sclust</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                                <span class="n">DistSClustClust</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">InCluster</span><span class="p">,</span> <span class="n">useObjects</span><span class="p">]</span>
                                <span class="n">MeanDist</span> <span class="o">=</span> <span class="n">DistSClustClust</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                                <span class="n">useColorsFac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">ColorsX</span><span class="p">[</span><span class="n">useObjects</span><span class="p">])</span>
                                <span class="n">MeanDist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;MeanDist&#39;</span><span class="p">:</span> <span class="n">MeanDist</span><span class="p">,</span> <span class="s1">&#39;useColorsFac&#39;</span><span class="p">:</span> <span class="n">useColorsFac</span><span class="p">})</span>
                                <span class="n">MeanMeanDist</span> <span class="o">=</span> <span class="n">MeanDist</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                                    <span class="s1">&#39;useColorsFac&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># tapply(MeanDist, useColorsFac, mean)</span>
                                <span class="n">nearest</span> <span class="o">=</span> <span class="n">MeanMeanDist</span><span class="p">[[</span><span class="s1">&#39;MeanDist&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                                <span class="n">NearestDist</span> <span class="o">=</span> <span class="n">MeanMeanDist</span><span class="p">[[</span><span class="s1">&#39;MeanDist&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NearestDist</span> <span class="o">&lt;</span> <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">nearest</span><span class="p">]),</span>
                                                 <span class="n">NearestDist</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                                    <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest</span>
                                    <span class="n">nPAMed</span> <span class="o">=</span> <span class="n">nPAMed</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">InCluster</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">Colors</span><span class="p">[</span><span class="n">InCluster</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">Unlabeled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Unlabeled</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pamRespectsDendro</span><span class="p">:</span>
                        <span class="n">unlabOnBranch</span> <span class="o">=</span> <span class="n">Unlabeled</span><span class="p">[</span><span class="n">onBranch</span><span class="p">[</span><span class="n">Unlabeled</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">unlabOnBranch</span><span class="p">:</span>
                            <span class="n">onBr</span> <span class="o">=</span> <span class="n">onBranch</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                            <span class="n">basicOnBranch</span> <span class="o">=</span> <span class="n">branch_basicClusters</span><span class="p">[[</span><span class="n">onBr</span><span class="p">]]</span>
                            <span class="n">labelsOnBranch</span> <span class="o">=</span> <span class="n">branchLabels</span><span class="p">[</span><span class="n">basicOnBranch</span><span class="p">]</span>
                            <span class="n">useObjects</span> <span class="o">=</span> <span class="n">ColorsX</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labelsOnBranch</span><span class="p">)</span>
                            <span class="n">useColorsFac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">ColorsX</span><span class="p">[</span><span class="n">useObjects</span><span class="p">])</span>
                            <span class="n">UnassdToClustDist</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">useObjects</span><span class="p">,</span> <span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                                <span class="s1">&#39;useColorsFac&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># tapply(distM[useObjects, obj], useColorsFac, mean)</span>
                            <span class="n">nearest</span> <span class="o">=</span> <span class="n">UnassdToClustDist</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
                            <span class="n">NearestClusterDist</span> <span class="o">=</span> <span class="n">UnassdToClustDist</span><span class="p">[</span><span class="n">nearest</span><span class="p">]</span>
                            <span class="n">nearestLabel</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">useColorsFac</span><span class="o">.</span><span class="n">categories</span><span class="p">[</span><span class="n">nearest</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">NearestClusterDist</span> <span class="o">&lt;</span> <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">nearest</span><span class="p">]),</span>
                                             <span class="n">NearestClusterDist</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">Colors</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest</span>
                                <span class="n">nPAMed</span> <span class="o">=</span> <span class="n">nPAMed</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">useObjects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ColorsX</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">useColorsFac</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">ColorsX</span><span class="p">[</span><span class="n">useObjects</span><span class="p">])</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">useObjects</span><span class="p">,</span> <span class="n">Unlabeled</span><span class="p">])</span>
                        <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;group&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">useColorsFac</span>
                        <span class="n">UnassdToClustDist</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                            <span class="p">[</span><span class="s1">&#39;group&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># apply(distM[useObjects, Unlabeled], 2, tapply, useColorsFac, mean)</span>
                        <span class="n">nearest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">UnassdToClustDist</span><span class="o">.</span><span class="n">idxmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                              <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">UnassdToClustDist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                            <span class="nb">int</span><span class="p">)</span>  <span class="c1"># apply(UnassdToClustDist, 2, which.min)</span>
                        <span class="n">nearestDist</span> <span class="o">=</span> <span class="n">UnassdToClustDist</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># apply(UnassdToClustDist, 2, min)</span>
                        <span class="n">nearestLabel</span> <span class="o">=</span> <span class="n">nearest</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">sumAssign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">nearestDist</span> <span class="o">&lt;</span> <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">nearest</span><span class="p">],</span> <span class="n">nearestDist</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">))</span>
                        <span class="n">assign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">nearestDist</span> <span class="o">&lt;</span> <span class="n">ClusterDiam</span><span class="p">[</span><span class="n">nearest</span><span class="p">],</span> <span class="n">nearestDist</span> <span class="o">&lt;</span> <span class="n">maxPamDist</span><span class="p">))[</span>
                            <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">Unlabeled</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">assign</span><span class="p">]</span>
                        <span class="n">Colors</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nearestLabel</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">assign</span><span class="p">]</span>
                        <span class="n">nPAMed</span> <span class="o">=</span> <span class="n">nPAMed</span> <span class="o">+</span> <span class="n">sumAssign</span>

        <span class="n">Colors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Colors</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">UnlabeledExist</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">Colors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">NumLabs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Colors</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
        <span class="n">Sizes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">NumLabs</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="n">OrdNumLabs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;Name&quot;</span><span class="p">:</span> <span class="n">NumLabs</span><span class="p">,</span> <span class="s2">&quot;Value&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">NumLabs</span><span class="p">))})</span>

        <span class="k">if</span> <span class="n">UnlabeledExist</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">SizeRank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">Sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">Sizes</span><span class="p">)],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">SizeRank</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NumLabs</span><span class="p">)):</span>
                <span class="n">OrdNumLabs</span><span class="o">.</span><span class="n">Value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SizeRank</span><span class="p">[</span><span class="n">NumLabs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">SizeRank</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">rankdata</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">Sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">Sizes</span><span class="p">)],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ordinal&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NumLabs</span><span class="p">)):</span>
                <span class="n">OrdNumLabs</span><span class="o">.</span><span class="n">Value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SizeRank</span><span class="p">[</span><span class="n">NumLabs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">OrdNumLabs</span><span class="o">.</span><span class="n">Value</span> <span class="o">=</span> <span class="n">OrdNumLabs</span><span class="o">.</span><span class="n">Value</span> <span class="o">-</span> <span class="n">UnlabeledExist</span>
        <span class="k">return</span> <span class="n">OrdNumLabs</span></div>

<div class="viewcode-block" id="WGCNA.labels2colors"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.labels2colors">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">labels2colors</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">zeroIsGrey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">colorSeq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">naColor</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a vector or array of numerical labels into a corresponding vector or array of colors corresponding to the labels.</span>

<span class="sd">        :param labels: list or matrix of non-negative integer or other (such as character) labels.</span>
<span class="sd">        :type labels: list or matrix</span>
<span class="sd">        :param zeroIsGrey: If TRUE, labels 0 will be assigned color grey. Otherwise, labels below 1 will trigger an error. (default = True)</span>
<span class="sd">        :type zeroIsGrey: bool</span>
<span class="sd">        :param colorSeq: Color sequence corresponding to labels. If not given, a standard sequence will be used.</span>
<span class="sd">        :type colorSeq: list or matrix</span>
<span class="sd">        :param naColor: Color that will encode missing values.</span>
<span class="sd">        :type naColor: str</span>

<span class="sd">        :return: An array of character strings of the same length or dimensions as labels.</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">colorSeq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">mcolors</span><span class="o">.</span><span class="n">CSS4_COLORS</span><span class="p">)</span>
            <span class="c1"># Sort colors by hue, saturation, value and name.</span>
            <span class="n">by_hsv</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">rgb_to_hsv</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">color</span><span class="p">)[:</span><span class="mi">3</span><span class="p">])),</span> <span class="n">name</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">colorSeq</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">hsv</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">by_hsv</span><span class="p">]</span>
            <span class="n">colorSeq</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">naColor</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">labels</span><span class="o">.</span><span class="n">Value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">zeroIsGrey</span><span class="p">:</span>
                <span class="n">minLabel</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minLabel</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">minLabel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
            <span class="n">nLabels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
            <span class="n">nLabels</span> <span class="o">=</span> <span class="n">factors</span><span class="o">.</span><span class="n">codes</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nLabels</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">colorSeq</span><span class="p">):</span>
            <span class="n">nRepeats</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">colorSeq</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">labels2colors: Number of labels exceeds number of avilable colors.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;Some colors will be repeated </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">nRepeats</span><span class="p">)</span><span class="si">}</span><span class="s2"> times.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">extColorSeq</span> <span class="o">=</span> <span class="n">colorSeq</span>
            <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nRepeats</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">colorSeq</span><span class="p">]</span>
                <span class="n">extColorSeq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">extColorSeq</span><span class="p">,</span> <span class="n">tmp</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nRepeats</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">extColorSeq</span> <span class="o">=</span> <span class="n">colorSeq</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nLabels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">fin</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nLabels</span><span class="o">.</span><span class="n">Value</span><span class="p">]</span>
        <span class="n">colors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ow">not</span> <span class="n">fin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> <span class="o">=</span> <span class="n">naColor</span>
        <span class="n">finLabels</span> <span class="o">=</span> <span class="n">nLabels</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">fin</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">colors</span><span class="p">[</span><span class="n">fin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">extColorSeq</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">finLabels</span><span class="o">.</span><span class="n">Value</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">colors</span></div>

<div class="viewcode-block" id="WGCNA.moduleEigengenes"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.moduleEigengenes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">moduleEigengenes</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nPC</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;along average&quot;</span><span class="p">,</span> <span class="n">excludeGrey</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grey</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span>
                         <span class="n">subHubs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">softPower</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">scaleVar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates module eigengenes (1st principal component) of modules in a given single dataset.</span>

<span class="sd">        :param expr: Expression data for a single set in the form of a data frame where rows are samples and columns are genes (probes).</span>
<span class="sd">        :type expr: pandas dataframe</span>
<span class="sd">        :param colors: A list of the same length as the number of probes in expr, giving module color for all probes (genes). Color &quot;grey&quot; is reserved for unassigned genes.</span>
<span class="sd">        :type colors: list</span>
<span class="sd">        :param impute: If TRUE, expression data will be checked for the presence of NA entries and if the latter are present, numerical data will be imputed. (defualt = True)</span>
<span class="sd">        :type impute: bool</span>
<span class="sd">        :param nPC: Number of principal components and variance explained entries to be calculated. Note that only the first principal component is returned; the rest are used only for the calculation of proportion of variance explained. If given nPC is greater than 10, a warning is issued. (default = 1)</span>
<span class="sd">        :type nPC: int</span>
<span class="sd">        :param align: Controls whether eigengenes, whose orientation is undetermined, should be aligned with average expression (align = &quot;along average&quot;) or left as they are (align = &quot;&quot;). Any other value will trigger an error. (default = &quot;along average&quot;)</span>
<span class="sd">        :type align: str</span>
<span class="sd">        :param excludeGrey: Should the improper module consisting of &#39;grey&#39; genes be excluded from the eigengenes (default = False)</span>
<span class="sd">        :type excludeGrey: bool</span>
<span class="sd">        :param grey: Value of colors designating the improper module. Note that if colors is a factor of numbers, the default value will be incorrect. (default = grey)</span>
<span class="sd">        :type grey: str</span>
<span class="sd">        :param subHubs: Controls whether hub genes should be substituted for missing eigengenes. If TRUE, each missing eigengene (i.e., eigengene whose calculation failed and the error was trapped) will be replaced by a weighted average of the most connected hub genes in the corresponding module. If this calculation fails, or if subHubs==FALSE, the value of trapErrors will determine whether the offending module will be removed or whether the function will issue an error and stop. (default = True)</span>
<span class="sd">        :type subHubs: bool</span>
<span class="sd">        :param softPower: The power used in soft-thresholding the adjacency matrix. Only used when the hubgene approximation is necessary because the principal component calculation failed. It must be non-negative. The default value should only be changed if there is a clear indication that it leads to incorrect results. (default = 6)</span>
<span class="sd">        :type softPower: int</span>
<span class="sd">        :param trapErrors: Controls handling of errors from that may arise when there are too many NA entries in expression data. If TRUE, errors from calling these functions will be trapped without abnormal exit. If FALSE, errors will cause the function to stop. Note, however, that subHubs takes precedence in the sense that if subHubs==TRUE and trapErrors==FALSE, an error will be issued only if both the principal component and the hubgene calculations have failed. (default = False)</span>
<span class="sd">        :type trapErrors: bool</span>
<span class="sd">        :param scaleVar: can be used to turn off scaling of the expression data before calculating the singular value decomposition. The scaling should only be turned off if the data has been scaled previously, in which case the function can run a bit faster. Note however that the function first imputes, then scales the expression data in each module. If the expression contain missing data, scaling outside of the function and letting the function impute missing data may lead to slightly different results than if the data is scaled within the function. (default = True)</span>
<span class="sd">        :type scaleVar: bool</span>

<span class="sd">        :return: A dictionary containing: &quot;eigengenes&quot;: Module eigengenes in a dataframe, with each column corresponding to one eigengene. The columns are named by the corresponding color with an &quot;ME&quot; prepended, e.g., MEturquoise etc. If returnValidOnly==FALSE, module eigengenes whose calculation failed have all components set to NA. &quot;averageExpr&quot;: If align == &quot;along average&quot;, a dataframe containing average normalized expression in each module. The columns are named by the corresponding color with an &quot;AE&quot; prepended, e.g., AEturquoise etc. &quot;varExplained&quot;: A dataframe in which each column corresponds to a module, with the component varExplained[PC, module] giving the variance of module module explained by the principal component no. PC. The calculation is exact irrespective of the number of computed principal components. At most 10 variance explained values are recorded in this dataframe. &quot;nPC&quot;: A copy of the input nPC. &quot;validMEs&quot;: A boolean vector. Each component (corresponding to the columns in data) is TRUE if the corresponding eigengene is valid, and FALSE if it is invalid. Valid eigengenes include both principal components and their hubgene approximations. When returnValidOnly==FALSE, by definition all returned eigengenes are valid and the entries of validMEs are all TRUE. &quot;validColors&quot;: A copy of the input colors with entries corresponding to invalid modules set to grey if given, otherwise 0 if colors is numeric and &quot;grey&quot; otherwise. &quot;allOK&quot;: Boolean flag signalling whether all eigengenes have been calculated correctly, either as principal components or as the hubgene average approximation. &quot;allPC&quot;: Boolean flag signalling whether all returned eigengenes are principal components. &quot;isPC&quot;: Boolean vector. Each component (corresponding to the columns in eigengenes) is TRUE if the corresponding eigengene is the first principal component and FALSE if it is the hubgene approximation or is invalid. &quot;isHub&quot;: Boolean vector. Each component (corresponding to the columns in eigengenes) is TRUE if the corresponding eigengene is the hubgene approximation and FALSE if it is the first principal component or is invalid. &quot;validAEs&quot;: Boolean vector. Each component (corresponding to the columns in eigengenes) is TRUE if the corresponding module average expression is valid. &quot;allAEOK&quot;: Boolean flag signalling whether all returned module average expressions contain valid data. Note that returnValidOnly==TRUE does not imply allAEOK==TRUE: some invalid average expressions may be returned if their corresponding eigengenes have been calculated correctly.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">OKCYAN</span><span class="si">}</span><span class="s2">Calculating </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span><span class="si">}</span><span class="s2"> module eigengenes in given set...</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">returnValidOnly</span> <span class="o">=</span> <span class="n">trapErrors</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">):</span>
            <span class="n">grey</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;moduleEigengenes: Error: expr is NULL.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;moduleEigengenes: Error: colors is NULL.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;moduleEigengenes: Error: expr must be two-dimensional.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;moduleEigengenes: Error: ncol(expr) and length(colors) must be equal (one color per gene).&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: &quot;Argument &#39;colors&#39; contains unused levels (empty modules). Use colors[, drop=TRUE] to get rid of them.&quot;</span>
        <span class="k">if</span> <span class="n">softPower</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;softPower must be non-negative&quot;</span><span class="p">)</span>
        <span class="n">maxVarExplained</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">nPC</span> <span class="o">&gt;</span> <span class="n">maxVarExplained</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Given nPC is too large. Will use value </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">maxVarExplained</span><span class="p">)</span><span class="si">}{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nVarExplained</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nPC</span><span class="p">,</span> <span class="n">maxVarExplained</span><span class="p">)</span>
        <span class="n">modlevels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">.</span><span class="n">categories</span>
        <span class="k">if</span> <span class="n">excludeGrey</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">modlevels</span> <span class="o">!=</span> <span class="n">grey</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">modlevels</span> <span class="o">=</span> <span class="n">modlevels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">modlevels</span> <span class="o">!=</span> <span class="n">grey</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Color levels are empty. Possible reason: the only color is grey and grey module is excluded &quot;</span>
                         <span class="s2">&quot;from the calculation.&quot;</span><span class="p">)</span>
        <span class="n">PrinComps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">)))</span>
        <span class="n">PrinComps</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">PrinComps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">PrinComps</span><span class="p">)</span>
        <span class="n">averExpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">expr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">)))</span>
        <span class="n">averExpr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">averExpr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">averExpr</span><span class="p">)</span>
        <span class="n">varExpl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nVarExplained</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">)))</span>
        <span class="n">varExpl</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">varExpl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">varExpl</span><span class="p">)</span>
        <span class="n">validMEs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">))</span>
        <span class="n">validAEs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">))</span>
        <span class="n">isPC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">))</span>
        <span class="n">isHub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">))</span>
        <span class="n">validColors</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="n">PrinComps</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ME&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">modlevel</span><span class="p">)</span> <span class="k">for</span> <span class="n">modlevel</span> <span class="ow">in</span> <span class="n">modlevels</span><span class="p">]</span>
        <span class="n">averExpr</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AE&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">modlevel</span><span class="p">)</span> <span class="k">for</span> <span class="n">modlevel</span> <span class="ow">in</span> <span class="n">modlevels</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">PrinComps</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">index</span>
            <span class="n">averExpr</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">index</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">modlevels</span><span class="p">)):</span>
            <span class="n">modulename</span> <span class="o">=</span> <span class="n">modlevels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">restrict1</span> <span class="o">=</span> <span class="p">(</span><span class="n">colors</span> <span class="o">==</span> <span class="n">modulename</span><span class="p">)</span>
            <span class="n">datModule</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">restrict1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">datModule</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">datModule</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">datModule</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">impute</span><span class="p">:</span>
                    <span class="n">seedSaved</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">datModule</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="c1"># define imputer</span>
                        <span class="n">imputer</span> <span class="o">=</span> <span class="n">KNNImputer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">datModule</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># fit on the dataset</span>
                        <span class="n">imputer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">datModule</span><span class="p">)</span>
                        <span class="c1"># transform the dataset</span>
                        <span class="n">datModule</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                            <span class="n">datModule</span><span class="p">)</span>  <span class="c1"># datModule = impute.knn(datModule, k = min(10, nrow(datModule) - 1))</span>
                <span class="k">if</span> <span class="n">scaleVar</span><span class="p">:</span>
                    <span class="n">datModule</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scale</span><span class="p">(</span><span class="n">datModule</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">datModule</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">datModule</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">datModule</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nPC</span><span class="p">)]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nPC</span><span class="p">),</span> <span class="p">:]</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">datModule</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tmp</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nVarExplained</span><span class="p">))]]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nVarExplained</span><span class="p">),</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">veMat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">varExpl</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nVarExplained</span><span class="p">),</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">veMat</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">pc</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">subHubs</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error!&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subHubs</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ..principal component calculation for module&quot;</span><span class="p">,</span> <span class="n">modulename</span><span class="p">,</span>
                          <span class="s2">&quot;failed with the following error:&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     ..hub genes will be used instead of principal components.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="n">isPC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">scaledExpr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">scale</span><span class="p">(</span><span class="n">datModule</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">datModule</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                                  <span class="n">columns</span><span class="o">=</span><span class="n">datModule</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                        <span class="n">covEx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">scaledExpr</span><span class="p">)</span>
                        <span class="n">covEx</span><span class="p">[</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">covEx</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">modAdj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">covEx</span><span class="p">)</span> <span class="o">**</span> <span class="n">softPower</span>
                        <span class="n">kIM</span> <span class="o">=</span> <span class="p">(</span><span class="n">modAdj</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">**</span> <span class="mi">3</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">kIM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">kIM</span> <span class="o">=</span> <span class="n">kIM</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">kIM</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">kIM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">hub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">kIM</span><span class="p">)</span>
                        <span class="n">alignSign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">covEx</span><span class="p">[:,</span> <span class="n">hub</span><span class="p">])</span>
                        <span class="n">alignSign</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">alignSign</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">isHub</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kIM</span> <span class="o">*</span> <span class="n">alignSign</span><span class="p">)</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">scaledExpr</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">pcxMat</span> <span class="o">=</span> <span class="n">scaledExpr</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kIM</span><span class="p">)</span>
                        <span class="n">pcx</span> <span class="o">=</span> <span class="n">pcxMat</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">varExpl</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">pcx</span><span class="p">,</span> <span class="n">datModule</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="n">pc</span> <span class="o">=</span> <span class="n">pcx</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">trapErrors</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error!&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ..ME calculation of module&quot;</span><span class="p">,</span> <span class="n">modulename</span><span class="p">,</span> <span class="s2">&quot;failed with the following error:&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     &quot;</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="s2">&quot; ..the offending module has been removed.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Eigengene calculation of module </span><span class="si">{</span><span class="n">modulename</span><span class="si">}</span><span class="s2"> failed with the following error </span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pc</span><span class="si">}</span><span class="s2"> The offending module has been removed.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">validMEs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">isPC</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">isHub</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">validColors</span><span class="p">[</span><span class="n">restrict1</span><span class="p">]</span> <span class="o">=</span> <span class="n">grey</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">PrinComps</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isPC</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">scaledExpr</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">datModule</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">averExpr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaledExpr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;along average&quot;</span><span class="p">:</span>
                        <span class="n">corAve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">averExpr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">PrinComps</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">corAve</span><span class="p">):</span>
                            <span class="n">corAve</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">corAve</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">PrinComps</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">PrinComps</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">validAEs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">trapErrors</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error!&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ..Average expression calculation of module&quot;</span><span class="p">,</span> <span class="n">modulename</span><span class="p">,</span>
                          <span class="s2">&quot;failed with the following error:&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ..the returned average expression vector will be invalid.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Average expression calculation of module </span><span class="si">{</span><span class="n">modulename</span><span class="si">}</span><span class="s2"> &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;failed with the following error.</span><span class="se">\n</span><span class="s2">The returned average expression vector will &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;be invalid.</span><span class="se">\n</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">allOK</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">validMEs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">returnValidOnly</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">validMEs</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">PrinComps</span> <span class="o">=</span> <span class="n">PrinComps</span><span class="p">[:,</span> <span class="n">validMEs</span><span class="p">]</span>
            <span class="n">averExpr</span> <span class="o">=</span> <span class="n">averExpr</span><span class="p">[:,</span> <span class="n">validMEs</span><span class="p">]</span>
            <span class="n">varExpl</span> <span class="o">=</span> <span class="n">varExpl</span><span class="p">[:,</span> <span class="n">validMEs</span><span class="p">]</span>
            <span class="n">validMEs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">PrinComps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">isPC</span> <span class="o">=</span> <span class="n">isPC</span><span class="p">[</span><span class="n">validMEs</span><span class="p">]</span>
            <span class="n">isHub</span> <span class="o">=</span> <span class="n">isHub</span><span class="p">[</span><span class="n">validMEs</span><span class="p">]</span>
            <span class="n">validAEs</span> <span class="o">=</span> <span class="n">validAEs</span><span class="p">[</span><span class="n">validMEs</span><span class="p">]</span>

        <span class="n">allPC</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">isPC</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">allAEOK</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">validAEs</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Done..</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;eigengenes&quot;</span><span class="p">:</span> <span class="n">PrinComps</span><span class="p">,</span> <span class="s2">&quot;averageExpr&quot;</span><span class="p">:</span> <span class="n">averExpr</span><span class="p">,</span> <span class="s2">&quot;varExplained&quot;</span><span class="p">:</span> <span class="n">varExpl</span><span class="p">,</span> <span class="s2">&quot;nPC&quot;</span><span class="p">:</span> <span class="n">nPC</span><span class="p">,</span>
                <span class="s2">&quot;validMEs&quot;</span><span class="p">:</span> <span class="n">validMEs</span><span class="p">,</span> <span class="s2">&quot;validColors&quot;</span><span class="p">:</span> <span class="n">validColors</span><span class="p">,</span> <span class="s2">&quot;allOK&quot;</span><span class="p">:</span> <span class="n">allOK</span><span class="p">,</span> <span class="s2">&quot;allPC&quot;</span><span class="p">:</span> <span class="n">allPC</span><span class="p">,</span> <span class="s2">&quot;isPC&quot;</span><span class="p">:</span> <span class="n">isPC</span><span class="p">,</span>
                <span class="s2">&quot;isHub&quot;</span><span class="p">:</span> <span class="n">isHub</span><span class="p">,</span> <span class="s2">&quot;validAEs&quot;</span><span class="p">:</span> <span class="n">validAEs</span><span class="p">,</span> <span class="s2">&quot;allAEOK&quot;</span><span class="p">:</span> <span class="n">allAEOK</span><span class="p">}</span></div>

<div class="viewcode-block" id="WGCNA.permissiveDim"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.permissiveDim">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">permissiveDim</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="WGCNA.checkSets"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.checkSets">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">checkSets</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">checkStructure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether given sets have the correct format and retrieves dimensions.</span>

<span class="sd">        :param data: A dict of lists; in each list there must be a component named data whose content is a matrix or dataframe or array of dimension 2.</span>
<span class="sd">        :type data: dict</span>
<span class="sd">        :param checkStructure: If FALSE, incorrect structure of data will trigger an error. If TRUE, an appropriate flag (see output) will be set to indicate whether data has correct structure. (default = False)</span>
<span class="sd">        :type checkStructure: bool</span>
<span class="sd">        :param useSets: Optional specification of entries of the list data that are to be checked. Defaults to all components. This may be useful when data only contains information for some of the sets.</span>
<span class="sd">        :type useSets: list</span>

<span class="sd">        :return: a dictionary contains: &quot;nSets&quot;: Number of sets (length of the vector data). &quot;nGenes&quot;: Number of columns in the data components in the lists. This number must be the same for all sets. &quot;nSamples&quot;: A vector of length nSets giving the number of rows in the data components. &quot;structureOK&quot;: Only set if the argument checkStructure equals TRUE. The value is TRUE if the paramter data passes a few tests of its structure, and FALSE otherwise. The tests are not exhaustive and are meant to catch obvious user errors rather than be bulletproof.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">nSets</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nSets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">useSets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useSets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nSets</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;No data given.&quot;</span><span class="p">)</span>
        <span class="n">structureOK</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">checkStructure</span><span class="p">:</span>
                <span class="n">structureOK</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">nGenes</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nSamples</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;data does not appear to have the correct format. &quot;</span>
                         <span class="s2">&quot;Consider using fixDataStructure or setting checkStructure = TRUE when calling this function.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">nSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nSets</span><span class="p">)</span>
            <span class="n">nGenes</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">permissiveDim</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">useSets</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;data&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nGenes</span> <span class="o">!=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">permissiveDim</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">checkStructure</span><span class="p">:</span>
                        <span class="n">structureOK</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Incompatible number of genes in set 1 and&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span><span class="p">)))</span>
                <span class="n">nSamples</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">permissiveDim</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nSamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nSets</span><span class="p">)</span>
            <span class="n">nGenes</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">permissiveDim</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">useSets</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nGenes</span> <span class="o">!=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">permissiveDim</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">set</span><span class="p">])[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">checkStructure</span><span class="p">:</span>
                        <span class="n">structureOK</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Incompatible number of genes in set 1 and&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span><span class="p">)))</span>
                <span class="n">nSamples</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">permissiveDim</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="nb">set</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;nSets&quot;</span><span class="p">:</span> <span class="n">nSets</span><span class="p">,</span> <span class="s2">&quot;nGenes&quot;</span><span class="p">:</span> <span class="n">nGenes</span><span class="p">,</span> <span class="s2">&quot;nSamples&quot;</span><span class="p">:</span> <span class="n">nSamples</span><span class="p">,</span> <span class="s2">&quot;structureOK&quot;</span><span class="p">:</span> <span class="n">structureOK</span><span class="p">}</span></div>

<div class="viewcode-block" id="WGCNA.fixDataStructure"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.fixDataStructure">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fixDataStructure</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encapsulates single-set data in a wrapper that makes the data suitable for functions working on multiset data collections.</span>

<span class="sd">        :param data: A dataframe, matrix or array with two dimensions to be encapsulated.</span>
<span class="sd">        :type data: pandas dataframe ot dict</span>

<span class="sd">        :return: input data in a format suitable for functions operating on multiset data collections.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fixDataStructure: data is not a Dictionary: converting it into one.&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">}}</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="WGCNA.multiSetMEs"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.multiSetMEs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">multiSetMEs</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">universalColors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useGenes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nPC</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">align</span><span class="o">=</span><span class="s2">&quot;along average&quot;</span><span class="p">,</span> <span class="n">excludeGrey</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subHubs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">softPower</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                    <span class="n">grey</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates module eigengenes for several sets.</span>

<span class="sd">        :param exprData: Expression data in a multi-set format</span>
<span class="sd">        :type exprData: pandas dataframe</span>
<span class="sd">        :param colors: A list of the same length as the number of probes in expr, giving module color for all probes (genes). Color &quot;grey&quot; is reserved for unassigned genes.</span>
<span class="sd">        :type colors: list</span>
<span class="sd">        :param universalColors: Alternative specification of module assignment</span>
<span class="sd">        :type universalColors: list</span>
<span class="sd">        :param useSets: If calculations are requested in (a) selected set(s) only, the set(s) can be specified here. Defaults to all sets.</span>
<span class="sd">        :type useSets: list</span>
<span class="sd">        :param useGenes: Can be used to restrict calculation to a subset of genes</span>
<span class="sd">        :type useGenes: list</span>
<span class="sd">        :param impute: If TRUE, expression data will be checked for the presence of NA entries and if the latter are present, numerical data will be imputed. (defualt = True)</span>
<span class="sd">        :type impute: bool</span>
<span class="sd">        :param nPC: Number of principal components and variance explained entries to be calculated. Note that only the first principal component is returned; the rest are used only for the calculation of proportion of variance explained. If given nPC is greater than 10, a warning is issued. (default = 1)</span>
<span class="sd">        :type nPC: int</span>
<span class="sd">        :param align: Controls whether eigengenes, whose orientation is undetermined, should be aligned with average expression (align = &quot;along average&quot;) or left as they are (align = &quot;&quot;). Any other value will trigger an error. (default = &quot;along average&quot;)</span>
<span class="sd">        :type align: str</span>
<span class="sd">        :param excludeGrey: Should the improper module consisting of &#39;grey&#39; genes be excluded from the eigengenes (default = False)</span>
<span class="sd">        :type excludeGrey: bool</span>
<span class="sd">        :param subHubs: Controls whether hub genes should be substituted for missing eigengenes. If TRUE, each missing eigengene (i.e., eigengene whose calculation failed and the error was trapped) will be replaced by a weighted average of the most connected hub genes in the corresponding module. If this calculation fails, or if subHubs==FALSE, the value of trapErrors will determine whether the offending module will be removed or whether the function will issue an error and stop. (default = True)</span>
<span class="sd">        :type subHubs: bool</span>
<span class="sd">        :param trapErrors: Controls handling of errors from that may arise when there are too many NA entries in expression data. If TRUE, errors from calling these functions will be trapped without abnormal exit. If FALSE, errors will cause the function to stop. Note, however, that subHubs takes precedence in the sense that if subHubs==TRUE and trapErrors==FALSE, an error will be issued only if both the principal component and the hubgene calculations have failed. (default = False)</span>
<span class="sd">        :type trapErrors: bool</span>
<span class="sd">        :param softPower: The power used in soft-thresholding the adjacency matrix. Only used when the hubgene approximation is necessary because the principal component calculation failed. It must be non-negative. The default value should only be changed if there is a clear indication that it leads to incorrect results. (default = 6)</span>
<span class="sd">        :type softPower: int</span>
<span class="sd">        :param grey: Value of colors or universalColors (whichever applies) designating the improper module</span>
<span class="sd">        :type grey: str</span>

<span class="sd">        :return: A dictionary similar in spirit to the input exprData</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">returnValidOnly</span> <span class="o">=</span> <span class="n">trapErrors</span>
        <span class="k">if</span> <span class="n">grey</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
                    <span class="n">grey</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grey</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">universalColors</span><span class="p">):</span>
                <span class="n">grey</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grey</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
        <span class="n">nSets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprData</span><span class="p">)</span>
        <span class="n">setsize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">)</span>
        <span class="n">nGenes</span> <span class="o">=</span> <span class="n">setsize</span><span class="p">[</span><span class="s1">&#39;nGenes&#39;</span><span class="p">]</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="n">setsize</span><span class="p">[</span><span class="s1">&#39;nSamples&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;multiSetMEs: Calculating module MEs.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">MEs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">consValidMEs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">consValidColors</span> <span class="o">=</span> <span class="n">universalColors</span>
        <span class="k">if</span> <span class="n">useSets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useSets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">useGenes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Working on set&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">setColors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[:,</span> <span class="nb">set</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">setColors</span> <span class="o">=</span> <span class="n">universalColors</span>
                <span class="n">setMEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">moduleEigengenes</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">exprData</span><span class="p">[</span><span class="nb">set</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="n">setColors</span><span class="p">,</span> <span class="n">impute</span><span class="o">=</span><span class="n">impute</span><span class="p">,</span> <span class="n">nPC</span><span class="o">=</span><span class="n">nPC</span><span class="p">,</span>
                                                <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">excludeGrey</span><span class="o">=</span><span class="n">excludeGrey</span><span class="p">,</span> <span class="n">grey</span><span class="o">=</span><span class="n">grey</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="n">trapErrors</span><span class="p">,</span>
                                                <span class="n">subHubs</span><span class="o">=</span><span class="n">subHubs</span><span class="p">,</span> <span class="n">softPower</span><span class="o">=</span><span class="n">softPower</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;allOK&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">consValidMEs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">consValidMEs</span> <span class="o">=</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">consValidMEs</span> <span class="o">=</span> <span class="n">consValidMEs</span> <span class="o">*</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span>
                    <span class="n">consValidColors</span><span class="p">[</span><span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validColors&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">universalColors</span><span class="p">]</span> <span class="o">=</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validColors&#39;</span><span class="p">][</span>
                        <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validColors&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">universalColors</span><span class="p">]</span>
                <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">setMEs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;eigengenes&quot;</span><span class="p">)</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="n">setMEs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Working on set&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span><span class="p">),</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">setColors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="n">useGenes</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">setColors</span> <span class="o">=</span> <span class="n">universalColors</span><span class="p">[</span><span class="n">useGenes</span><span class="p">]</span>
                <span class="n">setMEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">moduleEigengenes</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">exprData</span><span class="p">[[</span><span class="nb">set</span><span class="p">]][:,</span> <span class="n">useGenes</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="n">setColors</span><span class="p">,</span> <span class="n">impute</span><span class="o">=</span><span class="n">impute</span><span class="p">,</span>
                                                <span class="n">nPC</span><span class="o">=</span><span class="n">nPC</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">excludeGrey</span><span class="o">=</span><span class="n">excludeGrey</span><span class="p">,</span> <span class="n">grey</span><span class="o">=</span><span class="n">grey</span><span class="p">,</span>
                                                <span class="n">trapErrors</span><span class="o">=</span><span class="n">trapErrors</span><span class="p">,</span> <span class="n">subHubs</span><span class="o">=</span><span class="n">subHubs</span><span class="p">,</span> <span class="n">softPower</span><span class="o">=</span><span class="n">softPower</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;allOK&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">consValidMEs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">consValidMEs</span> <span class="o">=</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">consValidMEs</span> <span class="o">=</span> <span class="n">consValidMEs</span> <span class="o">*</span> <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span>
                    <span class="n">consValidColors</span><span class="p">[</span><span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validColors&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">universalColors</span><span class="p">[</span><span class="n">useGenes</span><span class="p">]]</span> <span class="o">=</span> \
                        <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validColors&#39;</span><span class="p">][</span><span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;validColors&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">universalColors</span><span class="p">[</span><span class="n">useGenes</span><span class="p">]]</span>
                <span class="n">setMEs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">setMEs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;eigengenes&quot;</span><span class="p">)</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="n">setMEs</span>
        <span class="k">if</span> <span class="n">universalColors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">consValidMEs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">consValidMEs</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validColors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">consValidColors</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">):</span>
            <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;allOK&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">returnValidOnly</span><span class="p">:</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">][:,</span> <span class="n">valid</span><span class="p">]</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">][:,</span> <span class="n">valid</span><span class="p">]</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;varExplained&#39;</span><span class="p">][:,</span> <span class="n">valid</span><span class="p">]</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;isPC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;isPC&#39;</span><span class="p">][</span><span class="n">valid</span><span class="p">]</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;allPC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;isPC&#39;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;isHub&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;isHub&#39;</span><span class="p">][</span><span class="n">valid</span><span class="p">]</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validAEs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validAEs&#39;</span><span class="p">][</span><span class="n">valid</span><span class="p">]</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;allAEOK&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validAEs&#39;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;validMEs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># names(MEs) = names(exprData)</span>
        <span class="k">return</span> <span class="n">MEs</span></div>

<div class="viewcode-block" id="WGCNA.consensusMEDissimilarityMajor"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.consensusMEDissimilarityMajor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">consensusMEDissimilarityMajor</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;consensus&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates consensus dissimilarity (1-cor) of given module eigengenes realized in several sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;consensus&quot;</span><span class="p">,</span> <span class="s2">&quot;majority&quot;</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">methods</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Unrecognized method given. Recognized values are&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">methods</span><span class="p">)))</span>
        <span class="n">nSets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">MEs</span><span class="p">)</span>
        <span class="n">MEDiss</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">useSets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useSets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">))</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">useAbs</span><span class="p">:</span>
                <span class="n">diss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">diss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">diss</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">MEDiss</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">MEDiss</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;Diss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">diss</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span> <span class="o">==</span> <span class="n">useSets</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">MEDiss</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;Diss&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ConsDiss</span><span class="p">,</span> <span class="n">MEDiss</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;Diss&#39;</span><span class="p">]])</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                        <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># pmax(ConsDiss, MEDiss[[set]][&#39;Diss&#39;])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">ConsDiss</span> <span class="o">+</span> <span class="n">MEDiss</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;Diss&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">ConsDiss</span> <span class="o">/</span> <span class="n">nSets</span>
        <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ConsDiss</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="n">useSets</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                                <span class="n">columns</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="n">useSets</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ConsDiss</span></div>

<div class="viewcode-block" id="WGCNA.clustOrder"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.clustOrder">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clustOrder</span><span class="p">(</span><span class="n">distM</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="s2">&quot;MEgrey&quot;</span><span class="p">):</span>
        <span class="n">distNames</span> <span class="o">=</span> <span class="n">distM</span><span class="o">.</span><span class="n">index</span>
        <span class="c1"># distM = distM.values</span>
        <span class="n">greyInd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">greyName</span> <span class="o">==</span> <span class="n">distNames</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">greyInd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">greyInd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">greyInd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">greyInd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">greyLast</span> <span class="ow">and</span> <span class="n">greyInd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clusterMEs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">greyName</span> <span class="o">!=</span> <span class="n">distNames</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusterMEs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">distM</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">clusterMEs</span><span class="p">,</span> <span class="n">clusterMEs</span><span class="p">]),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">dendrogram</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">no_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s1">&#39;leaves&#39;</span><span class="p">]</span>  <span class="c1"># order</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">greyInd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">greyInd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
                        <span class="n">order</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">greyInd</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">greyInd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distM</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">distM</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">dendrogram</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">no_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="s1">&#39;leaves&#39;</span><span class="p">]</span>  <span class="c1"># order</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">order</span></div>

<div class="viewcode-block" id="WGCNA.orderMEs"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.orderMEs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">orderMEs</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="s2">&quot;MEgrey&quot;</span><span class="p">,</span> <span class="n">orderBy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder given (eigen-)vectors such that similar ones (as measured by correlation) are next to each other.</span>

<span class="sd">        :param MEs: Module eigengenes in a multi-set format.</span>
<span class="sd">        :type MEs: dict</span>
<span class="sd">        :param greyLast: Normally the color grey is reserved for unassigned genes; hence the grey module is not a proper module and it is conventional to put it last. If this is not desired, set the parameter to FALSE. (default = True)</span>
<span class="sd">        :type greyLast:bool</span>
<span class="sd">        :param greyName: Name of the grey module eigengene. (default = &quot;MEgrey&quot;)</span>
<span class="sd">        :type greyName: str</span>
<span class="sd">        :param orderBy: Specifies the set by which the eigengenes are to be ordered (in all other sets as well). Defaults to the first set in useSets (or the first set, if useSets is not given). (defualt = 0)</span>
<span class="sd">        :type orderBy: int</span>
<span class="sd">        :param order: Allows the user to specify a custom ordering.</span>
<span class="sd">        :type order: list</span>
<span class="sd">        :param useSets: Allows the user to specify for which sets the eigengene ordering is to be performed.</span>
<span class="sd">        :type useSets: list</span>

<span class="sd">        :return: A dictionary of the same type as MEs containing the re-ordered eigengenes.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;eigengenes&quot;</span> <span class="ow">in</span> <span class="n">MEs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;orderMEs: order not given, calculating using given set&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">orderBy</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">disPC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">disPC</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">disPC</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">clustOrder</span><span class="p">(</span><span class="n">disPC</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="n">greyLast</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="n">greyName</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;orderMEs: given MEs and order have incompatible dimensions.&quot;</span><span class="p">)</span>
            <span class="n">orderedMEs</span> <span class="o">=</span> <span class="n">MEs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">orderedMEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">][:,</span> <span class="n">order</span><span class="p">])</span>
            <span class="n">orderedMEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">orderedMEs</span><span class="p">[</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">][:,</span> <span class="n">order</span><span class="p">])</span>
                <span class="n">orderedMEs</span><span class="p">[</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">orderedMEs</span><span class="p">[</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;varExplained&#39;</span><span class="p">][:,</span> <span class="n">order</span><span class="p">])</span>
                <span class="n">orderedMEs</span><span class="p">[</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="s1">&#39;eigengenes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">orderedMEs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">checkStructure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">[</span><span class="s1">&#39;structureOK&#39;</span><span class="p">]:</span>
                <span class="n">multiSet</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">multiSet</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">fixDataStructure</span><span class="p">(</span><span class="n">MEs</span><span class="p">)</span>
                <span class="n">useSets</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">orderBy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">useSets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">useSets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orderBy</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">orderBy</span> <span class="o">=</span> <span class="n">useSets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;orderMEs: order not given, calculating using given set&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">orderBy</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">disPC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">MEs</span><span class="p">[</span><span class="n">orderBy</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">disPC</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">disPC</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="n">orderBy</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">MEs</span><span class="p">[</span><span class="n">orderBy</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">clustOrder</span><span class="p">(</span><span class="n">disPC</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="n">greyLast</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="n">greyName</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MEs</span><span class="p">[</span><span class="n">orderBy</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;orderMEs: given MEs and order have incompatible dimensions.&quot;</span><span class="p">)</span>
            <span class="n">nSets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">MEs</span><span class="p">)</span>
            <span class="n">orderedMEs</span> <span class="o">=</span> <span class="n">MEs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">useSets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">useSets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">))</span>
            <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
                <span class="n">orderedMEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">order</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;averageExpr&quot;</span> <span class="ow">in</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">orderedMEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;averageExpr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">order</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;varExplained&quot;</span> <span class="ow">in</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">orderedMEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;varExplained&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">order</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">multiSet</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">orderedMEs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">orderedMEs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="WGCNA.consensusOrderMEs"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.consensusOrderMEs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">consensusOrderMEs</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="s2">&quot;MEgrey&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;consensus&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder given (eigen-)vectors such that similar ones (as measured by correlation) are next to each other.</span>

<span class="sd">        :param MEs: Module eigengenes of several sets in a multi-set format</span>
<span class="sd">        :type MEs: dict</span>
<span class="sd">        :param useAbs: Controls whether vector similarity should be given by absolute value of correlation or plain correlation. (defualt = False)</span>
<span class="sd">        :type useAbs: bool</span>
<span class="sd">        :param useSet: Allows the user to specify for which sets the eigengene ordering is to be performed.</span>
<span class="sd">        :type useSets: list</span>
<span class="sd">        :param greyLast: Normally the color grey is reserved for unassigned genes; hence the grey module is not a proper module and it is conventional to put it last. If this is not desired, set the parameter to FALSE. (defualt = True)</span>
<span class="sd">        :type greyLast: bool</span>
<span class="sd">        :param greyName: Name of the grey module eigengene. (defualt = &quot;MEgrey&quot;)</span>
<span class="sd">        :type greyName: str</span>
<span class="sd">        :param method: A character string giving the method to be used calculating the consensus dissimilarity. Allowed values are (abbreviations of) &quot;consensus&quot; and &quot;majority&quot;. The consensus dissimilarity is calculated as the maximum of given set dissimilarities for &quot;consensus&quot; and as the average for &quot;majority&quot;.</span>
<span class="sd">        :type method: str</span>

<span class="sd">        :return: A dictionary of the same type as MEs containing the re-ordered eigengenes</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Diss</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">consensusMEDissimilarityMajor</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="n">useAbs</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">clustOrder</span><span class="p">(</span><span class="n">Diss</span><span class="p">,</span> <span class="n">greyLast</span><span class="p">,</span> <span class="n">greyName</span><span class="p">)</span>
        <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">orderMEs</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="n">greyLast</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="n">greyName</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MEs</span></div>

<div class="viewcode-block" id="WGCNA.equalizeQuantilesFun"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.equalizeQuantilesFun">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">equalizeQuantilesFun</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">summaryType</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">]):</span>
        <span class="c1"># summaryType = match.arg(summaryType)</span>
        <span class="n">data_sorted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># apply(data, 2, sort)</span>
        <span class="k">if</span> <span class="n">summaryType</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">refSample</span> <span class="o">=</span> <span class="n">data_sorted</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">summaryType</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">refSample</span> <span class="o">=</span> <span class="n">data_sorted</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">refSample</span><span class="p">[</span><span class="n">ranks</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># dim(out = dim(data)</span>
        <span class="c1"># dimnames(out) = dimnames(data)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="WGCNA.consensusMEDissimilarity"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.consensusMEDissimilarity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">consensusMEDissimilarity</span><span class="p">(</span><span class="n">multiMEs</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equalizeQuantiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quantileSummary</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                                 <span class="n">corOptions</span><span class="o">=</span><span class="p">{},</span> <span class="n">consensusQuantile</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="s2">&quot;ME0&quot;</span><span class="p">):</span>
        <span class="n">nSets</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">multiMEs</span><span class="p">)[</span><span class="s1">&#39;nSets&#39;</span><span class="p">]</span>
        <span class="n">useMEs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">multiMEs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">greyName</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">useNames</span> <span class="o">=</span> <span class="n">multiMEs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">useMEs</span><span class="p">]</span>
        <span class="n">nUseMEs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">useMEs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">useSets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">useSets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">))</span>
        <span class="n">nUseSets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">useSets</span><span class="p">)</span>
        <span class="n">MEDiss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nUseMEs</span><span class="p">,</span> <span class="n">nUseMEs</span><span class="p">,</span> <span class="n">nUseSets</span><span class="p">))</span>
        <span class="n">MEDiss</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">useSets</span><span class="p">:</span>
            <span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">multiMEs</span><span class="p">[</span><span class="nb">set</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">useMEs</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">useAbs</span><span class="p">:</span>
                <span class="n">diss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diss</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">diss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">diss</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">corOptions</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">MEDiss</span><span class="p">[:,</span> <span class="p">:,</span> <span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="n">diss</span>
        <span class="k">if</span> <span class="n">equalizeQuantiles</span><span class="p">:</span>
            <span class="n">distMat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MEDiss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">distMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">MEDiss</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="c1"># distMat = apply(MEDiss, 3, function(x) { as.numeric( as.dist(x))})</span>
            <span class="c1"># TODO: checkdistMat.shape = [nUseMEs * (nUseMEs - 1) / 2, nUseSets]</span>
            <span class="n">normalized</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">equalizeQuantilesFun</span><span class="p">(</span><span class="n">distMat</span><span class="p">,</span> <span class="n">summaryType</span><span class="o">=</span><span class="n">quantileSummary</span><span class="p">)</span>
            <span class="c1"># TODO:apply(normalized, 2, .turnDistVectorIntoMatrix, size = nUseMEs, Diag = FALSE, Upper = FALSE, diagValue = 0)</span>
            <span class="n">MEDiss</span> <span class="o">=</span> <span class="n">normalized</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">normalized</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">MEDiss</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">consensusQuantile</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">useNames</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span>
                                <span class="n">columns</span><span class="o">=</span><span class="n">useNames</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ConsDiss</span></div>

<div class="viewcode-block" id="WGCNA.moduleNumber"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.moduleNumber">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">moduleNumber</span><span class="p">(</span><span class="n">dendro</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">minSize</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="n">Branches</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">cutree</span><span class="p">(</span><span class="n">dendro</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="n">cutHeight</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">NOnBranches</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">Branches</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">TrueBranch</span> <span class="o">=</span> <span class="n">NOnBranches</span> <span class="o">&gt;=</span> <span class="n">minSize</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">TrueBranch</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Branches</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Branches</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">TrueBranch</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">Branches</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">Branches</span></div>

<div class="viewcode-block" id="WGCNA.mergeCloseModules"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.mergeCloseModules">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mergeCloseModules</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">MEs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">checkDataFormat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">unassdColor</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">equalizeQuantiles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">quantileSummary</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                          <span class="n">consensusQuantile</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">relabel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">colorSeq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">getNewMEs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">getNewUnassdME</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges modules in gene expression networks that are too close as measured by the correlation of their eigengenes.</span>

<span class="sd">        :param exprData: Expression data, either a single data frame with rows corresponding to samples and columns to genes, or in a multi-set format.</span>
<span class="sd">        :type exprData: pandas dataframe</span>
<span class="sd">        :param colors: A list (numeric, character or a factor) giving module colors for genes. The method only makes sense when genes have the same color label in all sets, hence a single list.</span>
<span class="sd">        :type colors: list</span>
<span class="sd">        :param MEs: If module eigengenes have been calculated before, the user can save some computational time by inputting them. MEs should have the same format as exprData. If they are not given, they will be calculated.</span>
<span class="sd">        :type MEs: dict</span>
<span class="sd">        :param useSets: A list of scalar allowing the user to specify which sets will be used to calculate the consensus dissimilarity of module eigengenes. Defaults to all given sets.</span>
<span class="sd">        :type useSets: list</span>
<span class="sd">        :param impute: Should missing values be imputed in eigengene calculation? If imputation is disabled, the presence of NA entries will cause the eigengene calculation to fail and eigengenes will be replaced by their hubgene approximation. (defualt = True)</span>
<span class="sd">        :type impute: bool</span>
<span class="sd">        :param checkDataFormat: If TRUE, the function will check exprData and MEs for correct multi-set structure. If single set data is given, it will be converted into a format usable for the function. If FALSE, incorrect structure of input data will trigger an error. (defualt = True)</span>
<span class="sd">        :type checkDataFormat: bool</span>
<span class="sd">        :param unassdColor: Specifies the string that labels unassigned genes. Module of this color will not enter the module eigengene clustering and will not be merged with other modules. (default = &quot;grey&quot;)</span>
<span class="sd">        :type unassdColor: str</span>
<span class="sd">        :param useAbs: Specifies whether absolute value of correlation or plain correlation (of module eigengenes) should be used in calculating module dissimilarity. (defualt = False)</span>
<span class="sd">        :type useAbs: bool</span>
<span class="sd">        :param equalizeQuantiles: should quantiles of the eigengene dissimilarity matrix be equalized (&quot;quantile normalized&quot;)? The default is FALSE for reproducibility of old code; when there are many eigengenes (e.g., at least 50), better results may be achieved if quantile equalization is used. (defualt = False)</span>
<span class="sd">        :type equalizeQuantiles: bool</span>
<span class="sd">        :param quantileSummary: One of &quot;mean&quot; or &quot;median&quot;. Controls how a reference dissimilarity is computed from the input ones (using mean or median, respectively). (default = &quot;mean&quot;)</span>
<span class="sd">        :type quantileSummary: str</span>
<span class="sd">        :param consensusQuantile: A number giving the desired quantile to use in the consensus similarity calculation. (defualt = 0)</span>
<span class="sd">        :type consensusQuantile: int</span>
<span class="sd">        :param cutHeight: Maximum dissimilarity (i.e., 1-correlation) that qualifies modules for merging. (defualt = 0.2)</span>
<span class="sd">        :type cutHeight: float</span>
<span class="sd">        :param iterate: Controls whether the merging procedure should be repeated until there is no change. If FALSE, only one iteration will be executed. (defualt = True)</span>
<span class="sd">        :type iterate: bool</span>
<span class="sd">        :param relabel: Controls whether, after merging, color labels should be ordered by module size. (defualt = False)</span>
<span class="sd">        :type relabel: bool</span>
<span class="sd">        :param colorSeq: Color labels to be used for relabeling. Defaults to the standard color order used in this package if colors are not numeric, and to integers starting from 1 if colors is numeric.</span>
<span class="sd">        :type colorSeq: list</span>
<span class="sd">        :param getNewMEs: Controls whether module eigengenes of merged modules should be calculated and returned. (defualt = True)</span>
<span class="sd">        :type getNewMEs: bool</span>
<span class="sd">        :param getNewUnassdME: When doing module eigengene manipulations, the function does not normally calculate the eigengene of the &#39;module&#39; of unassigned (&#39;grey&#39;) genes. Setting this option to TRUE will force the calculation of the unassigned eigengene in the returned newMEs, but not in the returned oldMEs. (defualt = True)</span>
<span class="sd">        :type getNewUnassdME: bool</span>
<span class="sd">        :param trapErrors: Controls whether computational errors in calculating module eigengenes, their dissimilarity, and merging trees should be trapped. If TRUE, errors will be trapped and the function will return the input colors. If FALSE, errors will cause the function to stop. (defualt = False)</span>

<span class="sd">        :return: A dictionaty contains: &quot;colors&quot;: Color labels for the genes corresponding to merged modules. The function attempts to mimic the mode of the input colors: if the input colors is numeric, character and factor, respectively, so is the output. Note, however, that if the fnction performs relabeling, a standard sequence of labels will be used: integers starting at 1 if the input colors is numeric, and a sequence of color labels otherwise. &quot;dendro&quot;: Hierarchical clustering dendrogram (average linkage) of the eigengenes of the most recently computed tree. If iterate was set TRUE, this will be the dendrogram of the merged modules, otherwise it will be the dendrogram of the original modules. &quot;oldDendro&quot;: Hierarchical clustering dendrogram (average linkage) of the eigengenes of the original modules. &quot;cutHeight&quot;: The input cutHeight. &quot;oldMEs&quot;: Module eigengenes of the original modules in the sets given by useSets. &quot;newMEs&quot;: Module eigengenes of the merged modules in the sets given by useSets. &quot;allOK&quot;: A boolean set to TRUE.</span>
<span class="sd">        :raises trapErrors==TRUE: A dictionaty contains: &quot;colors&quot;: A copy of the input colors. &quot;allOK&quot;: a boolean set to FALSE.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">):</span>
            <span class="n">unassdColor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">MEsInSingleFrame</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">origColors</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="n">greyName</span> <span class="o">=</span> <span class="s2">&quot;ME&quot;</span> <span class="o">+</span> <span class="n">unassdColor</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mergeCloseModules: Merging modules whose distance is less than&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cutHeight</span><span class="p">),</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">checkStructure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">)[</span><span class="s1">&#39;structureOK&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">checkDataFormat</span><span class="p">:</span>
                <span class="n">exprData</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">fixDataStructure</span><span class="p">(</span><span class="n">exprData</span><span class="p">)</span>
                <span class="n">MEsInSingleFrame</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Given exprData appear to be misformatted.&quot;</span><span class="p">)</span>
        <span class="n">setsize</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">)</span>
        <span class="n">nSets</span> <span class="o">=</span> <span class="n">setsize</span><span class="p">[</span><span class="s1">&#39;nSets&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">MEs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">checkMEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">checkStructure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">checkMEs</span><span class="p">[</span><span class="s1">&#39;structureOK&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">setsize</span><span class="p">[</span><span class="s1">&#39;nSets&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">checkMEs</span><span class="p">[</span><span class="s1">&#39;nSets&#39;</span><span class="p">]:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Input error: numbers of sets in exprData and MEs differ.&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="nb">set</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nSets</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">checkMEs</span><span class="p">[</span><span class="s1">&#39;nSamples&#39;</span><span class="p">][</span><span class="nb">set</span><span class="p">]</span> <span class="o">!=</span> <span class="n">setsize</span><span class="p">[</span><span class="s1">&#39;nSamples&#39;</span><span class="p">][</span><span class="nb">set</span><span class="p">]:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Number of samples in MEs is incompatible with subset length for set&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">set</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">MEsInSingleFrame</span><span class="p">:</span>
                    <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">fixDataStructure</span><span class="p">(</span><span class="n">MEs</span><span class="p">)</span>
                    <span class="n">checkMEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkSets</span><span class="p">(</span><span class="n">MEs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;MEs do not have the appropriate structure (same as exprData). &quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">setsize</span><span class="p">[</span><span class="s1">&#39;nGenes&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Number of genes in exprData is different from the length of original colors. They must equal.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cutHeight</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cutHeight</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">useAbs</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">((</span><span class="s2">&quot;Given cutHeight is out of sensible range between 0 and&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">useAbs</span><span class="p">)))</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">iteration</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">MergedColors</span> <span class="o">=</span> <span class="n">colors</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">MEs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">multiSetMEs</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">universalColors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span>
                                            <span class="n">impute</span><span class="o">=</span><span class="n">impute</span><span class="p">,</span> <span class="n">subHubs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">excludeGrey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">grey</span><span class="o">=</span><span class="n">unassdColor</span><span class="p">)</span>
                    <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">consensusOrderMEs</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="n">useAbs</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">checkMEs</span><span class="p">[</span><span class="s1">&#39;nGenes&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">&quot;Number of given module colors does not match number of given MEs =&gt; recalculating the MEs.&quot;</span><span class="p">,</span>
                            <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">multiSetMEs</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">universalColors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span>
                                            <span class="n">impute</span><span class="o">=</span><span class="n">impute</span><span class="p">,</span> <span class="n">subHubs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">excludeGrey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">grey</span><span class="o">=</span><span class="n">unassdColor</span><span class="p">)</span>
                    <span class="n">MEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">consensusOrderMEs</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="n">useAbs</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">oldMEs</span> <span class="o">=</span> <span class="n">MEs</span>
                <span class="n">colLevs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colLevs</span><span class="p">[</span><span class="n">colLevs</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">unassdColor</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mergeCloseModules: less than two proper modules.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ..color levels are&quot;</span><span class="p">,</span> <span class="n">colLevs</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; ..there is nothing to merge.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">MergedNewColors</span> <span class="o">=</span> <span class="n">colors</span>
                    <span class="n">MergedColors</span> <span class="o">=</span> <span class="n">colors</span>
                    <span class="n">nOldMods</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">nNewMods</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">oldTree</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">Tree</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>
                <span class="n">nOldMods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
                <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">consensusMEDissimilarity</span><span class="p">(</span><span class="n">MEs</span><span class="p">,</span> <span class="n">equalizeQuantiles</span><span class="o">=</span><span class="n">equalizeQuantiles</span><span class="p">,</span>
                                                          <span class="n">quantileSummary</span><span class="o">=</span><span class="n">quantileSummary</span><span class="p">,</span>
                                                          <span class="n">consensusQuantile</span><span class="o">=</span><span class="n">consensusQuantile</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="n">useAbs</span><span class="p">,</span>
                                                          <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="n">greyName</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">ConsDiss</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">Tree</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iteration</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">oldTree</span> <span class="o">=</span> <span class="n">Tree</span>
                <span class="n">TreeBranches</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">cutree</span><span class="p">(</span><span class="n">Tree</span><span class="p">,</span> <span class="n">cutHeight</span><span class="o">=</span><span class="n">cutHeight</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">UniqueBranches</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">TreeBranches</span><span class="p">)</span>
                <span class="n">nBranches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">UniqueBranches</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
                <span class="n">NumberOnBranch</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">TreeBranches</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
                <span class="n">MergedColors</span> <span class="o">=</span> <span class="n">colors</span>
                <span class="n">TreeBranches</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">TreeBranches</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">ConsDiss</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nBranches</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">NumberOnBranch</span><span class="p">[</span><span class="n">branch</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">ModulesOnThisBranch</span> <span class="o">=</span> <span class="n">TreeBranches</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">TreeBranches</span> <span class="o">==</span> <span class="n">UniqueBranches</span><span class="p">[</span><span class="n">branch</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
                        <span class="n">ColorsOnThisBranch</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ModulesOnThisBranch</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">origColors</span><span class="p">):</span>
                            <span class="n">ColorsOnThisBranch</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ColorsOnThisBranch</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ColorsOnThisBranch</span><span class="p">)):</span>
                            <span class="n">MergedColors</span><span class="p">[</span><span class="n">MergedColors</span> <span class="o">==</span> <span class="n">ColorsOnThisBranch</span><span class="p">[</span><span class="n">color</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ColorsOnThisBranch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># MergedColors = MergedColors[:, drop = TRUE]</span>
                <span class="n">nNewMods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">MergedColors</span><span class="p">)</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nNewMods</span> <span class="o">&lt;</span> <span class="n">nOldMods</span> <span class="ow">and</span> <span class="n">iterate</span><span class="p">:</span>
                    <span class="n">colors</span> <span class="o">=</span> <span class="n">MergedColors</span>
                    <span class="n">MEs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">iteration</span> <span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">relabel</span><span class="p">:</span>
                <span class="n">RawModuleColors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">MergedColors</span><span class="p">)</span><span class="o">.</span><span class="n">codes</span>
                <span class="k">if</span> <span class="n">colorSeq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">origColors</span><span class="p">):</span>
                        <span class="n">colorSeq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">origColors</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">())))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nNewColors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">RawModuleColors</span><span class="p">)</span>
                        <span class="n">colorSeq</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">labels2colors</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nNewColors</span><span class="p">)))</span>
                <span class="n">nGenesInModule</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">MergedColors</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
                <span class="n">SortedRawModuleColors</span> <span class="o">=</span> <span class="n">RawModuleColors</span><span class="p">[</span><span class="n">nGenesInModule</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
                <span class="n">MergedNewColors</span> <span class="o">=</span> <span class="n">MergedColors</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">,</span> <span class="n">MergedNewColors</span><span class="p">):</span>
                    <span class="n">MergedNewColors</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">MergedNewColors</span><span class="p">)</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SortedRawModuleColors</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">SortedRawModuleColors</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">!=</span> <span class="n">unassdColor</span><span class="p">:</span>
                        <span class="n">rank</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">MergedNewColors</span><span class="p">[</span><span class="n">MergedColors</span> <span class="o">==</span> <span class="n">SortedRawModuleColors</span><span class="p">[</span><span class="n">color</span><span class="p">]]</span> <span class="o">=</span> <span class="n">colorSeq</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">,</span> <span class="n">MergedColors</span><span class="p">):</span>
                    <span class="n">MergedNewColors</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">MergedNewColors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">MergedNewColors</span> <span class="o">=</span> <span class="n">MergedColors</span>
            <span class="c1"># MergedNewColors = MergedNewColors[, drop = TRUE]</span>
            <span class="k">if</span> <span class="n">getNewMEs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nNewMods</span> <span class="o">&lt;</span> <span class="n">nOldMods</span> <span class="ow">or</span> <span class="n">relabel</span> <span class="ow">or</span> <span class="n">getNewUnassdME</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Calculating new MEs...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">NewMEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">multiSetMEs</span><span class="p">(</span><span class="n">exprData</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">universalColors</span><span class="o">=</span><span class="n">MergedNewColors</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span>
                                               <span class="n">impute</span><span class="o">=</span><span class="n">impute</span><span class="p">,</span> <span class="n">subHubs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trapErrors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">excludeGrey</span><span class="o">=</span><span class="ow">not</span> <span class="n">getNewUnassdME</span><span class="p">,</span> <span class="n">grey</span><span class="o">=</span><span class="n">unassdColor</span><span class="p">)</span>
                    <span class="n">newMEs</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">consensusOrderMEs</span><span class="p">(</span><span class="n">NewMEs</span><span class="p">,</span> <span class="n">useAbs</span><span class="o">=</span><span class="n">useAbs</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span> <span class="n">greyLast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">greyName</span><span class="o">=</span><span class="n">greyName</span><span class="p">)</span>
                    <span class="n">ConsDiss</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">consensusMEDissimilarity</span><span class="p">(</span><span class="n">newMEs</span><span class="p">,</span> <span class="n">equalizeQuantiles</span><span class="o">=</span><span class="n">equalizeQuantiles</span><span class="p">,</span>
                                                              <span class="n">quantileSummary</span><span class="o">=</span><span class="n">quantileSummary</span><span class="p">,</span>
                                                              <span class="n">consensusQuantile</span><span class="o">=</span><span class="n">consensusQuantile</span><span class="p">,</span>
                                                              <span class="n">useAbs</span><span class="o">=</span><span class="n">useAbs</span><span class="p">,</span> <span class="n">useSets</span><span class="o">=</span><span class="n">useSets</span><span class="p">,</span> <span class="n">greyName</span><span class="o">=</span><span class="n">greyName</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ConsDiss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">Tree</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">ConsDiss</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">Tree</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newMEs</span> <span class="o">=</span> <span class="n">MEs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newMEs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">MEsInSingleFrame</span><span class="p">:</span>
                <span class="n">newMEs</span> <span class="o">=</span> <span class="n">newMEs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># $data</span>
                <span class="n">oldMEs</span> <span class="o">=</span> <span class="n">oldMEs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># $data</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">trapErrors</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: merging of modules failed&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; --&gt; returning unmerged modules and *no* eigengenes.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">mergeCloseModules: merging of modules failed --&gt; returning unmerged modules and *no* &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;eigengenes.</span><span class="se">\n</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;colors&quot;</span><span class="p">:</span> <span class="n">origColors</span><span class="p">,</span> <span class="s2">&quot;allOK&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;colors&quot;</span><span class="p">:</span> <span class="n">MergedNewColors</span><span class="p">,</span> <span class="s2">&quot;dendro&quot;</span><span class="p">:</span> <span class="n">Tree</span><span class="p">,</span> <span class="s2">&quot;oldDendro&quot;</span><span class="p">:</span> <span class="n">oldTree</span><span class="p">,</span> <span class="s2">&quot;cutHeight&quot;</span><span class="p">:</span> <span class="n">cutHeight</span><span class="p">,</span>
                    <span class="s2">&quot;oldMEs&quot;</span><span class="p">:</span> <span class="n">oldMEs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="s2">&quot;newMEs&quot;</span><span class="p">:</span> <span class="n">newMEs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="s2">&quot;allOK&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span></div>

<div class="viewcode-block" id="WGCNA.corPvalue"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.corPvalue">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">corPvalue</span><span class="p">(</span><span class="n">cor</span><span class="p">,</span> <span class="n">nSamples</span><span class="p">):</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nSamples</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cor</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">cor</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">nSamples</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pt</span></div>

<div class="viewcode-block" id="WGCNA.saveWGCNA"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.saveWGCNA">[docs]</a>    <span class="k">def</span> <span class="nf">saveWGCNA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the current WGCNA in pickle format with the .p extension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">BOLD</span><span class="si">}{</span><span class="n">OKBLUE</span><span class="si">}</span><span class="s2">Saving WGCNA as </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.p</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">picklefile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.p&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picklefile</span><span class="p">)</span>
        <span class="n">picklefile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="WGCNA.getDatTraits"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.getDatTraits">[docs]</a>    <span class="k">def</span> <span class="nf">getDatTraits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get data trait module base on samples information</span>

<span class="sd">        :return: a dataframe contains information in suitable format for plotting module trait relationship heatmap</span>
<span class="sd">        :rtype: pandas dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">datTraits</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">sample_id</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;sample_id&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">datTraits</span><span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">org</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">org</span><span class="p">)))</span>
                <span class="n">datTraits</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">org</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">rep</span><span class="p">,</span>
                                       <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]):</span>
                    <span class="n">datTraits</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">org</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">org</span><span class="p">))</span>
                    <span class="n">rep</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">org</span> <span class="o">==</span> <span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">org</span> <span class="o">=</span> <span class="n">org</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="n">rep</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">datTraits</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">org</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">rep</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">datTraits</span></div>

<div class="viewcode-block" id="WGCNA.getModuleName"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.getModuleName">[docs]</a>    <span class="k">def</span> <span class="nf">getModuleName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get names of modules</span>

<span class="sd">        :return: name of modules</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="WGCNA.getGeneModule"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.getGeneModule">[docs]</a>    <span class="k">def</span> <span class="nf">getGeneModule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get list of genes corresponding to modules</span>

<span class="sd">        :param moduleName: name of modules</span>
<span class="sd">        :type moduleName: list</span>

<span class="sd">        :return: A dictionary contains list of genes for requested module(s)</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">moduleColors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">moduleName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">moduleColors</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Module name(s) does not exist in </span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">moduleColors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">moduleName</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">color</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="WGCNA.getModulesGene"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.getModulesGene">[docs]</a>    <span class="k">def</span> <span class="nf">getModulesGene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geneIds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get list of modules corresponding to gene(s)</span>

<span class="sd">        :param geneIds: gene id</span>
<span class="sd">        :type geneIds: list or str</span>

<span class="sd">        :return: A list contains name of module(s) for requested gene(s)</span>
<span class="sd">        :rtype: list or str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geneIds</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">geneIds</span> <span class="o">=</span> <span class="p">[</span><span class="n">geneIds</span><span class="p">]</span>

        <span class="n">modules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">geneId</span> <span class="ow">in</span> <span class="n">geneIds</span><span class="p">:</span>
            <span class="n">modules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">moduleColors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">gene_id</span> <span class="o">==</span> <span class="n">geneId</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">modules</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="n">modules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">modules</span></div>

<div class="viewcode-block" id="WGCNA.setMetadataColor"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.setMetadataColor">[docs]</a>    <span class="k">def</span> <span class="nf">setMetadataColor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set color pallete for each group of metadata</span>

<span class="sd">        :param col: name of metadata</span>
<span class="sd">        :type col: str</span>
<span class="sd">        :param cmap: color pallet</span>
<span class="sd">        :type cmap: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if obs_col is even there</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Metadata column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> not found!</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmap</span></div>

<div class="viewcode-block" id="WGCNA.plotModuleEigenGene"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.plotModuleEigenGene">[docs]</a>    <span class="k">def</span> <span class="nf">plotModuleEigenGene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plot module eigen gene figure in given module</span>

<span class="sd">        :param moduleName: module name</span>
<span class="sd">        :type moduleName: str</span>
<span class="sd">        :param metadata: list of metadata you want to be plotted</span>
<span class="sd">        :type metadata: list</span>
<span class="sd">        :param show: indicate if you want to see plots in when you run your code</span>
<span class="sd">        :type show: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sampleInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span>

        <span class="n">height_ratios</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
            <span class="n">height_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">height_ratios</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">modules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">moduleName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Module name does not exist in </span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heatmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">moduleName</span><span class="p">]</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
            <span class="n">heatmap</span> <span class="o">=</span> <span class="p">(</span><span class="n">heatmap</span><span class="o">-</span><span class="n">heatmap</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">heatmap</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">heatmap</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">heatmap</span> <span class="o">=</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">T</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">heatmap</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">hclust</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">)</span>
            <span class="c1"># Clusterize the data</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">fcluster</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>
            <span class="c1"># Keep the indices to sort labels</span>
            <span class="n">labels_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">heatmap</span> <span class="o">=</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">labels_order</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">ME</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="p">[</span><span class="s2">&quot;ME&quot;</span> <span class="o">+</span> <span class="n">moduleName</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">])</span>
            <span class="n">ME</span><span class="p">[</span><span class="s1">&#39;sample_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="o">.</span><span class="n">index</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">),</span>
                                    <span class="n">sharex</span><span class="o">=</span><span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span>
                    <span class="s1">&#39;height_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">],</span>
                    <span class="s1">&#39;width_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
            <span class="n">gs</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_gridspec</span><span class="p">()</span>
            <span class="c1"># remove the underlying axes</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="n">ax_legend</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">ax_legend</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">axs_legend</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpecFromSubplotSpec</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">subplot_spec</span><span class="o">=</span><span class="n">ax_legend</span><span class="p">,</span>
                                                          <span class="n">height_ratios</span><span class="o">=</span><span class="n">height_ratios</span><span class="p">)</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ME</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
                <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3000</span> <span class="o">*</span> <span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">sampleInfo</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">],</span> <span class="n">color</span><span class="p">)</span>
                    <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1600</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                <span class="n">ax_legend</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Subplot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axs_legend</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>
                <span class="n">ax_legend</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">handles</span><span class="o">=</span><span class="n">handles</span><span class="p">)</span>
                <span class="n">ax_legend</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">ax_legend</span><span class="p">)</span>

            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Module Eigengene for </span><span class="si">{</span><span class="n">moduleName</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">28</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2000</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ME</span><span class="o">.</span><span class="n">eigengeneExp</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>

            <span class="n">cmap</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;dark:red&quot;</span><span class="p">,</span> <span class="n">as_cmap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">heatmap</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                        <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># cbar_ax=axs[2,1],</span>
                        <span class="n">yticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">show</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/ModuleHeatmapEigengene&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="WGCNA.barplotModuleEigenGene"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.barplotModuleEigenGene">[docs]</a>    <span class="k">def</span> <span class="nf">barplotModuleEigenGene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">colorBar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        bar plot of module eigen gene figure in given module</span>

<span class="sd">        :param moduleName: module name</span>
<span class="sd">        :type moduleName: str</span>
<span class="sd">        :param metadata: list of metadata you want to be plotted</span>
<span class="sd">        :type metadata: list</span>
<span class="sd">        :param combine: indicate if you want to combine all metadata to show them together</span>
<span class="sd">        :type combine: bool</span>
<span class="sd">        :praram colorBar: metadata you want to use to color bar plot with</span>
<span class="sd">        :type colorBar: str</span>
<span class="sd">        :param show: indicate if you want to see plots in when you run your code</span>
<span class="sd">        :type show: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sampleInfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">obs</span>

        <span class="n">height_ratios</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
            <span class="n">height_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
        <span class="n">height_ratios</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">modules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">moduleName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Module name does not exist in </span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ME</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="p">[</span><span class="s2">&quot;ME&quot;</span> <span class="o">+</span> <span class="n">moduleName</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">ME</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampleInfo</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">cat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">])</span>
                <span class="n">cat</span><span class="p">[</span><span class="n">metadata</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ybar</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;eigengeneExp&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;all&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()[</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">]</span>
                <span class="n">ebar</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;eigengeneExp&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;all&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">std</span><span class="p">()[</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">]</span>
                <span class="n">ybar</span> <span class="o">=</span> <span class="n">ybar</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cat</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]]</span>
                <span class="n">ebar</span> <span class="o">=</span> <span class="n">ebar</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cat</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]]</span>
                <span class="n">label</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ybar</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="n">dot</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;eigengeneExp&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ind</span><span class="p">[</span><span class="n">cat</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dot</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">xdot</span> <span class="o">=</span> <span class="n">dot</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span>
                <span class="n">ydot</span> <span class="o">=</span> <span class="n">dot</span><span class="p">[</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">colorBar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">palette</span> <span class="o">=</span> <span class="s2">&quot;lightblue&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">palette</span> <span class="o">=</span> <span class="n">cat</span><span class="p">[[</span><span class="n">colorBar</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">palette</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">colorBar</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">palette</span> <span class="o">=</span> <span class="n">palette</span><span class="p">[</span><span class="n">colorBar</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
                                        <span class="n">sharex</span><span class="o">=</span><span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span>
                        <span class="s1">&#39;height_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">],</span>
                        <span class="s1">&#39;width_ratios&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">cat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">]})</span>

                <span class="n">gs</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_gridspec</span><span class="p">()</span>
                <span class="c1"># remove the underlying axes</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
                <span class="n">ax_legend</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">ax_legend</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                <span class="n">axs_legend</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpecFromSubplotSpec</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">subplot_spec</span><span class="o">=</span><span class="n">ax_legend</span><span class="p">,</span>
                                                              <span class="n">height_ratios</span><span class="o">=</span><span class="n">height_ratios</span><span class="p">)</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
                    <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">ind</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3000</span> <span class="o">*</span> <span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">cat</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">color</span> <span class="o">==</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">],</span> <span class="n">color</span><span class="p">)</span>
                        <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">colorBar</span><span class="p">:</span>
                        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1600</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                    <span class="n">ax_legend</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Subplot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axs_legend</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">metadata</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>
                    <span class="n">ax_legend</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">handles</span><span class="o">=</span><span class="n">handles</span><span class="p">)</span>
                    <span class="n">ax_legend</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">ax_legend</span><span class="p">)</span>

                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Module Eigengene for </span><span class="si">{</span><span class="n">moduleName</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">28</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2000</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ybar</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">palette</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ybar</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">ebar</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xdot</span><span class="p">,</span> <span class="n">ydot</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)))</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;eigengeneExp&#39;</span><span class="p">)</span>
                <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/barplot_&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">show</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)):</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">ME</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sampleInfo</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
                    <span class="n">palette</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadataColors</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">bar</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;eigengeneExp&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span> <span class="n">ci</span><span class="o">=</span><span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                                      <span class="n">ax</span><span class="o">=</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">bar</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/barplot_&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">show</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.findGoTerm"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.findGoTerm">[docs]</a>    <span class="k">def</span> <span class="nf">findGoTerm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">GoSets</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GO_Biological_Process_2021&#39;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        find and plot gene ontology(GO) for given module</span>

<span class="sd">        :param moduleName: module name</span>
<span class="sd">        :type moduleName: str</span>
<span class="sd">        :param GoSets: sets of datasets of GO term you want to consider</span>
<span class="sd">        :type GoSets: list of str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/Go_term/&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Go_term directory does not exist!</span><span class="se">\n</span><span class="s2">Creating Go_term directory!</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/Go_term/&#39;</span><span class="p">)</span>

        <span class="n">modules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">moduleName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Module name does not exist in </span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geneModule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">gene_name</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">moduleColors</span> <span class="o">==</span> <span class="n">moduleName</span><span class="p">]</span>
            <span class="n">enr</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">enrichr</span><span class="p">(</span><span class="n">gene_list</span><span class="o">=</span><span class="n">geneModule</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                             <span class="n">gene_sets</span><span class="o">=</span><span class="n">GoSets</span><span class="p">,</span>
                             <span class="n">organism</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
                             <span class="n">description</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                             <span class="n">outdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/Go_term/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span><span class="p">,</span>
                             <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">dotplot</span><span class="p">(</span><span class="n">enr</span><span class="o">.</span><span class="n">res2d</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Gene ontology in &quot;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s2">&quot; module with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;moduleColors&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">moduleName</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; genes&quot;</span><span class="p">,</span>
                    <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis_r&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                    <span class="n">ofname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/Go_term/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.updateGeneInfo"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.updateGeneInfo">[docs]</a>    <span class="k">def</span> <span class="nf">updateGeneInfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geneInfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add/update genes info in datExpr and geneExpr anndata</span>

<span class="sd">        :param geneInfo: gene information table you want to add to your data</span>
<span class="sd">        :type geneInfo: pandas dataframe</span>
<span class="sd">        :param path: path of geneInfo</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :param sep: separation symbol to use for reading data in path properly</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :param order: if you want to update/add gene information by keeping the order as the same as data. if you want to add gene infor from biomart you should set this to be false. (default: TRUE)</span>
<span class="sd">        :type order: bool</span>
<span class="sd">        :param level: indicated the expression data is at gene level or transcript level</span>
<span class="sd">        :type level: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geneExpr</span> <span class="o">=</span> <span class="n">GeneExp</span><span class="o">.</span><span class="n">updateGeneInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geneExpr</span><span class="p">,</span> <span class="n">geneInfo</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span> <span class="o">=</span> <span class="n">GeneExp</span><span class="o">.</span><span class="n">updateGeneInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">geneInfo</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.updateMetadata"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.updateMetadata">[docs]</a>    <span class="k">def</span> <span class="nf">updateMetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metaData</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add/update metadata in datExpr and geneExpr anndata</span>

<span class="sd">        :param metaData: Sample information table you want to add to your data</span>
<span class="sd">        :type metaData: pandas dataframe</span>
<span class="sd">        :param path: path of metaData</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :param sep: separation symbol to use for reading data in path properly</span>
<span class="sd">        :type sep: str</span>
<span class="sd">        :param order: if you want to update/add gene information by keeping the order as the same as data. if you want to add gene infor from biomart you should set this to be false. (default: TRUE)</span>
<span class="sd">        :type order: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geneExpr</span> <span class="o">=</span> <span class="n">GeneExp</span><span class="o">.</span><span class="n">updateMetadata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geneExpr</span><span class="p">,</span> <span class="n">metaData</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span> <span class="o">=</span> <span class="n">GeneExp</span><span class="o">.</span><span class="n">updateMetadata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">metaData</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.softConnectivity"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.softConnectivity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">softConnectivity</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">corOptions</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;unsigned&quot;</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">blockSize</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
                         <span class="n">minNSamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given expression data or a similarity, the function constructs the adjacency matrix and for each node calculates its connectivity, that is the sum of the adjacency to the other nodes.</span>

<span class="sd">        :param datExpr: a data frame containing the expression data, with rows corresponding to samples and columns to genes.</span>
<span class="sd">        :type datExpr: pandas dataframe</span>
<span class="sd">        :param corOptions: character string giving further options to be passed to the correlation function.</span>
<span class="sd">        :type corOptions: pandas dataframe</span>
<span class="sd">        :param weights: optional observation weights for datExpr to be used in correlation calculation. A matrix of the same dimensions as datExpr, containing non-negative weights. Only used with Pearson correlation.</span>
<span class="sd">        :type weights: pandas dataframe</span>
<span class="sd">        :param type: network type. Allowed values are (unique abbreviations of) &quot;unsigned&quot;, &quot;signed&quot;, &quot;signed hybrid&quot;.</span>
<span class="sd">        :type type: str</span>
<span class="sd">        :param power: soft thresholding power.</span>
<span class="sd">        :type power: int</span>
<span class="sd">        :param blockSize: block size in which adjacency is to be calculated. Too low (say below 100) may make the calculation inefficient, while too high may cause R to run out of physical memory and slow down the computer. Should be chosen such that an array of doubles of size (number of genes) * (block size) fits into available physical memory.</span>
<span class="sd">        :type blockSize: int</span>
<span class="sd">        :param minNSamples: minimum number of samples available for the calculation of adjacency for the adjacency to be considered valid. If not given, defaults to the greater of ..minNSamples (currently 4) and number of samples divided by 3. If the number of samples falls below this threshold, the connectivity of the corresponding gene will be returned as NA.</span>
<span class="sd">        :type minNSamples: int</span>

<span class="sd">        :return: A list with one entry per gene giving the connectivity of each gene in the weighted network.</span>
<span class="sd">        :rtype: ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;signed&quot;</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="mi">15</span>

        <span class="n">nGenes</span> <span class="o">=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nSamples</span> <span class="o">=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">blockSize</span> <span class="o">*</span> <span class="n">nGenes</span> <span class="o">&gt;</span> <span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_AS</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">blockSize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">getrlimit</span><span class="p">(</span><span class="n">resource</span><span class="o">.</span><span class="n">RLIMIT_AS</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">nGenes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">minNSamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">minNSamples</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">nSamples</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nGenes</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="ow">or</span> <span class="n">nSamples</span> <span class="o">&lt;</span> <span class="n">minNSamples</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Error: Something seems to be wrong. </span><span class="se">\n</span><span class="s2"> Make sure that the input data frame has genes as rows and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;array samples as columns.</span><span class="se">\n</span><span class="s2"> Alternatively, there seem to be fewer than 10 genes or fewer than &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">minNSamples</span><span class="si">}</span><span class="s2"> samples.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nGenes</span> <span class="o">&lt;</span> <span class="n">nSamples</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Warning: There are fewer genes than samples in the function softConnectivity. Maybe you &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;should transpose the data?</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nGenes</span><span class="p">,))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">nGenes</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">blockSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nGenes</span><span class="p">)</span>
            <span class="n">index1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">ad1</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">adjacency</span><span class="p">(</span><span class="n">datExpr</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">selectCols</span><span class="o">=</span><span class="n">index1</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">,</span> <span class="n">adjacencyType</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
                                  <span class="n">corOptions</span><span class="o">=</span><span class="n">corOptions</span><span class="p">)</span>
            <span class="n">k</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ad1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># If fewer than minNSamples contain gene expression information for a given</span>
            <span class="c1"># gene, then we set its connectivity to 0.</span>
            <span class="n">NoSamplesAvailable</span> <span class="o">=</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">index1</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">k</span><span class="p">[</span><span class="n">index1</span><span class="p">][</span><span class="n">NoSamplesAvailable</span> <span class="o">&lt;</span> <span class="n">minNSamples</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">k</span></div>

<div class="viewcode-block" id="WGCNA.intramodularConnectivity"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.intramodularConnectivity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">intramodularConnectivity</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates intramodular connectivity, i.e., connectivity of nodes to other nodes within the same module.</span>

<span class="sd">        :param mat: adjacency which should be a square, symmetric matrix with entries between 0 and 1.</span>
<span class="sd">        :type mat: ndarray</span>
<span class="sd">        :param colors: module labels. A list of length ncol(adjMat) giving a module label for each gene (node) of the network.</span>
<span class="sd">        :type colors: list</span>
<span class="sd">        :param scaleByMax: should intramodular connectivity be scaled by the maximum IM connectivity in each module?</span>
<span class="sd">        :type scaleByMax: bool</span>
<span class="sd">        :param index: gene id or name of mat index</span>
<span class="sd">        :type index: ndarray</span>

<span class="sd">        :return: If input getWholeNetworkConnectivity is TRUE, a data frame with 4 columns giving the total connectivity, intramodular connectivity, extra-modular connectivity, and the difference of the intra- and extra-modular connectivities for all genes; otherwise a vector of intramodular connectivities</span>
<span class="sd">        :rtype: pandas dataframe</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;input matrix is not a square matrix.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Dimensions of matrix (number of genes) and length of &#39;colors&#39; differ.&quot;</span><span class="p">)</span>

        <span class="n">nNodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
        <span class="n">colorLevels</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">.</span><span class="n">categories</span>
        <span class="n">nLevels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">colorLevels</span><span class="p">)</span>
        <span class="n">kWithin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nNodes</span><span class="p">,))</span>

        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nLevels</span><span class="p">):</span>
            <span class="n">rest1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">colors</span> <span class="o">==</span> <span class="n">colorLevels</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rest1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">kWithin</span><span class="p">[</span><span class="n">colors</span> <span class="o">==</span> <span class="n">colorLevels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kWithin</span><span class="p">[</span><span class="n">rest1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">rest1</span><span class="p">,</span> <span class="n">rest1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">scaleByMax</span><span class="p">:</span>
                    <span class="n">kWithin</span><span class="p">[</span><span class="n">rest1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kWithin</span><span class="p">[</span><span class="n">rest1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">kWithin</span><span class="p">[</span><span class="n">rest1</span><span class="p">])</span>
        <span class="n">kTotal</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># apply(adjMat, 2, sum, na.rm = TRUE)</span>
        <span class="n">kOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">kTotal</span><span class="p">,</span> <span class="n">kWithin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scaleByMax</span><span class="p">:</span>
            <span class="n">kOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nNodes</span><span class="p">,))</span>
        <span class="n">kDiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">kWithin</span><span class="p">,</span> <span class="n">kOut</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;kTotal&#39;</span><span class="p">:</span> <span class="n">kTotal</span><span class="p">,</span> <span class="s1">&#39;kWithin&#39;</span><span class="p">:</span> <span class="n">kWithin</span><span class="p">,</span> <span class="s1">&#39;kOut&#39;</span><span class="p">:</span> <span class="n">kOut</span><span class="p">,</span> <span class="s1">&#39;kDiff&#39;</span><span class="p">:</span> <span class="n">kDiff</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="WGCNA.CalculateSignedKME"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.CalculateSignedKME">[docs]</a>    <span class="k">def</span> <span class="nf">CalculateSignedKME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprWeights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">MEWeights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculation of (signed) eigengene-based connectivity, also known as module membership.</span>

<span class="sd">        :param exprWeights: optional weight matrix of observation weights for datExpr, of the same dimensions as datExpr</span>
<span class="sd">        :type exprWeights: pandas dataframe</span>
<span class="sd">        :param MEWeights: optional weight matrix of observation weights for datME, of the same dimensions as datME</span>
<span class="sd">        :type MEWeights: pandas dataframe</span>

<span class="sd">        :return: A data frame in which rows correspond to input genes and columns to module eigengenes, giving the signed eigengene-based connectivity of each gene with respect to each eigengene.</span>
<span class="sd">        :rtype: pandas dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corOptions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datME</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Number of samples (rows) in &#39;datExpr&#39; and &#39;datME&#39; must be the same.&quot;</span><span class="p">)</span>
        <span class="n">datExpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span>
        <span class="n">datME</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datME</span>
        <span class="k">if</span> <span class="n">exprWeights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exprWeights</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkAndScaleWeights</span><span class="p">(</span><span class="n">exprWeights</span><span class="p">,</span> <span class="n">datExpr</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">MEWeights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">MEWeights</span> <span class="o">=</span> <span class="n">WGCNA</span><span class="o">.</span><span class="n">checkAndScaleWeights</span><span class="p">(</span><span class="n">exprWeights</span><span class="p">,</span> <span class="n">datME</span><span class="p">,</span> <span class="n">scaleByMax</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">varianceZeroIndicatordatExpr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">varianceZeroIndicatordatME</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">datME</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">varianceZeroIndicatordatExpr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Some genes are constant. Hint: consider removing constant columns from datExpr.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">varianceZeroIndicatordatME</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Some module eigengenes are constant, which is suspicious. Hint: consider removing &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;constant columns from datME.</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">MEWeights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corOptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;weights.y = MEWeights, &quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exprWeights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corOptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;weights.x = exprWeights, &quot;</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">datExpr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">datME</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">datME</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;k&quot;</span> <span class="o">+</span> <span class="n">datME</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">datExpr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:],</span>
                                      <span class="n">index</span><span class="o">=</span><span class="n">datExpr</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">col</span><span class="p">)</span></div>

<div class="viewcode-block" id="WGCNA.CoexpressionModulePlot"><a class="viewcode-back" href="../../PyWGCNA.html#PyWGCNA.wgcna.WGCNA.CoexpressionModulePlot">[docs]</a>    <span class="k">def</span> <span class="nf">CoexpressionModulePlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">numGenes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">numConnections</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">minTOM</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">filterCols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepCats</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plot Coexpression for given module</span>

<span class="sd">        :param module: name of modules you like to plot</span>
<span class="sd">        :type module: str</span>
<span class="sd">        :param numGenes: number of genes you want to show</span>
<span class="sd">        :type numGenes: int</span>
<span class="sd">        :param numConnections: number of connection you want to show</span>
<span class="sd">        :type numConnections: int</span>
<span class="sd">        :param minTOM: minimum TOM to keep connections</span>
<span class="sd">        :type minTOM: float</span>

<span class="sd">        :return: save a html file with name of modules in figures directory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;signedKME is empty! call signedKME() to calcuate it&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/network/&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">WARNING</span><span class="si">}</span><span class="s2">Network directory does not exist!</span><span class="se">\n</span><span class="s2">Creating network directory!</span><span class="si">{</span><span class="n">ENDC</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/network/&#39;</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;gene_id&#39;</span>
        <span class="n">name_biotype</span> <span class="o">=</span> <span class="s1">&#39;gene_biotype&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span> <span class="o">==</span> <span class="s1">&#39;transcript&#39;</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;transcript_id&#39;</span>
            <span class="n">name_biotype</span> <span class="o">=</span> <span class="s1">&#39;transcript_biotype&#39;</span>
        <span class="n">gene_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">moduleColors</span> <span class="o">==</span> <span class="n">module</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">filterCols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filterCols</span><span class="p">)):</span>
                <span class="n">gene_id</span> <span class="o">=</span> <span class="n">gene_id</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_id</span><span class="p">[</span><span class="n">filterCols</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="n">keepCats</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">gene_id</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">gene_id</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gene_id</span> <span class="o">=</span> <span class="n">gene_id</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">numGenes</span><span class="p">:</span>
            <span class="n">numGenes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_id</span><span class="p">)</span>
            <span class="n">numConnections</span> <span class="o">=</span> <span class="n">numGenes</span> <span class="o">*</span> <span class="p">(</span><span class="n">numGenes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signedKME</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_id</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;kME&quot;</span> <span class="o">+</span> <span class="n">module</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">numGenes</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">TOM</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TOM</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">to_df</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TOM</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mat</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">adj</span> <span class="o">&lt;</span> <span class="n">minTOM</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">))</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">adj</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span><span class="o">.</span><span class="n">nlargest</span><span class="p">(</span><span class="n">numConnections</span><span class="p">)</span>

        <span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
        <span class="n">gene_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">gene_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">gene_id</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datExpr</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene_id</span><span class="p">,]</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">name_biotype</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[</span><span class="n">name_biotype</span><span class="p">]</span>
        <span class="n">net</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]),</span>
                      <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                      <span class="n">label</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">gene_name</span><span class="p">),</span>
                      <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="n">module</span><span class="p">]</span> <span class="o">*</span> <span class="n">numGenes</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">net</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span>
                             <span class="n">adj</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="n">i</span><span class="p">],</span>
                             <span class="n">weight</span><span class="o">=</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">net</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outputPath</span> <span class="o">+</span> <span class="s1">&#39;/figures/network/&#39;</span> <span class="o">+</span> <span class="n">module</span> <span class="o">+</span> <span class="s1">&#39;.html&#39;</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Narges Rezaie.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>